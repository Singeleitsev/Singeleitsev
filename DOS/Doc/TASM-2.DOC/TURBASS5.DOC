                                    Выбирайте                                  
         =================================================================

                              Авторский коллектив "*.*"
                             под руководством Орлова С.Б.



                            ПРОГРАММА-СПРАВОЧНИК по системе
                        программирования ТУРБО АССЕМБЛЕР 2.0

                              СПРАВОЧНОЕ РУКОВОДСТВО

                                 #5/5 (Приложения)




                                 г.Москва, 1990 г.

         =================================================================

                                   Оглавление                                  
         TASM2 #5-5/Док                = 1 =

         ПРИЛОЖЕНИЕ A. ОБОБЩЕННЫЙ СИНТАКСИС ТУРБО АССЕМБЛЕРА.............9
           Лексика.......................................................9
           Выражения в режиме MASM......................................12
           Выражения в режиме IDEAL.....................................15
         ПРИЛОЖЕНИЕ B  СОВМЕСТИМОСТЬ....................................18
           Ассемблирование в один и два прохода.........................18
           Переменные операционной среды................................19
           Формат чисел с плавающей точкой фирмы Microsoft..............19
           Режим QUIRKS.................................................19
           Пересылка байта в сегментный регистр и из него...............20
           Ошибочные переходы ближнего типа к дальней метке или
            процедуре...................................................20
           Потеря информации о типе в директивах = и EQU................21
           Проверка выравнивания сегмента...............................21
           Арифметические и логические инструкции для работы
            непосредственно со знаковыми числами........................22
           Средства MASM версии 5.1.....................................22
           Средства режима /QUIRKS MASM версии 5.1......................23
           Совместимость с QUASM........................................24
         ПРИЛОЖЕНИЕ C  ОСОБЕННОСТИ  ТУРБО  АССЕМБЛЕРА...................26
           Расширенный синтаксис командной строки.......................26
           Директива GLOBAL.............................................27
           Директива PUBLICDDL..........................................27
           Расширение директивы COMM....................................27
           Локальные идентификаторы.....................................27
           Расширение инструкций условных переходов.....................27
           Режим IDEAL..................................................28
           Вложенные директивы UNION/STRUC..............................28
           Директивы EMUL И NOEMUL......................................28
           Префиксы переопределения сегмента............................28
           Постоянные сегменты..........................................29
           Расширенная инструкция CALL..................................29
           Расширенные инструкции PUSH и POP............................29
           Расширения, касающиеся конкретного языка.....................30
           Расширенная инструкция LOOP в режиме процессора 80386........31
           Расширенное управление листингом.............................31
           Альтернативные директивы.....................................31
           Предопределенные переменные..................................32
           Расширения MASM 5.0 и 5.1....................................32
           Расширенное управление директивами SHR и SHL.................34
           Возможности многопроходной обработки.........................34
         ПРИЛОЖЕНИЕ D. УТИЛИТЫ  ТУРБО  АССЕМБЛЕРА.......................35
         АВТОНОМНАЯ УТИЛИТА MAKE........................................36
           Как работает утилита MAKE....................................37
           Запуск утилиты MAKE..........................................38
           Как прервать выполнение утилиты MAKE.........................40

         TASM2 #5-5/Док                = 2 =

           Файл BULTINS.MAK.............................................40
           Небольшой пример.............................................41
           Параметры командной строки...................................43
           Простое использование утилиты MAKE...........................44
           Создание формирующих файлов..................................47
           Компоненты формирующих файлов................................49
           Комментарии..................................................50
           Командные списки.............................................51
           Тело команды.................................................52
           Списки программ..............................................53
           Выполнение команд DOS........................................54
           Явные правила................................................57
           Специальные соглашения.......................................60
           Примеры......................................................60
           Автоматическая проверка зависимости..........................61
           Неявные правила..............................................62
           Специальные соглашения.......................................65
           Примеры......................................................65
           Примеры......................................................66
           Макроопределения.............................................67
           Определение макрокоманд......................................70
           Использование макрокоманд....................................71
           Особые случаи................................................72
           Предопределенные макрокоманды................................73
           Директивы....................................................77
           Директивы с точками..........................................78
           Директивы включения файлов...................................80
           Условные директивы...........................................81
           Выражения, допустимые в условных директивах..................83
           Директива error..............................................85
           Директива undef..............................................86
           Сообщения об ошибках утилиты MAKE............................86
           Сообщения о фатальных ошибках................................86
           Сообщения об ошибках.........................................89
         БИБЛИОТЕКАРЬ TLIB..............................................93
           Преимущества использования библиотек объектных модулей.......94
           Составные части командной строки TLIB........................95
           Список операций..............................................97
           Имя файла и модуля...........................................97
           Операции TLIB................................................98
           Создание библиотеки..........................................99
           Использование файлов подсказки...............................99
           Создание расширенного словаря: параметр /E..................100
           Задание размера страницы: параметр /P.......................101
           Параметр /C.................................................101
           Примеры.....................................................102

         TASM2 #5-5/Док                = 3 =

         КОМПОНОВЩИК TLINK.............................................103
           Использование файлов подсказки..............................105
           Параметры компоновщика......................................106
           Параметр /l.................................................109
           Параметр /i.................................................109
           Параметр /n.................................................109
           Параметр /c.................................................109
           Параметр /d.................................................109
           Параметр /e.................................................110
           Параметр /t.................................................111
           Параметр /v.................................................111
           tlink mod1 /v+ mod2 mod3 /v- mod4...........................111
           Параметр /3.................................................112
         Ограничения...................................................113
           Сообщения об ошибках........................................113
         Сообщения о фатальных ошибках.................................114
         Сообщения об ошибках..........................................120
           XXX is unresolved in module YYY.............................120
           Fixup overflow, frame = xxxxh, target = xxxxh,..............120
           Out of memory...............................................120
           Undefined symbol <идентификатор> in module <модуль>.........121
         Предупреждения................................................122
         Утилита TOUCH.................................................123
         Параметры командной строки....................................124
         GREP: УТИЛИТА ПОИСКА ТЕКСТА В ФАЙЛАХ..........................125
           Параметры утилиты GREP......................................125
           Порядок следования..........................................127
         Строка поиска.................................................128
         Операторы в обычных выражениях................................129
         Спецификация файла............................................130
           Примеры с пояснениями.......................................130
         OBJXREF: УТИЛИТА ДЛЯ РАБОТЫ С ПЕРЕКРЕСТНЫМИ ССЫЛКАМИ В
          ОБЪЕКТНЫХ МОДУЛЯХ............................................135
           Командная строка утилиты OBJXREF............................135
           Параметры командной строки утилиты OBJXREF..................136
         Файлы подсказок...............................................138
         Простые отчеты утилиты OBJXREF................................140
           Отчет об общих именах (/RP).................................141
         Отчет о модуле (/RM)..........................................143
           Отчет о ссылках (/RR) (по умолчанию)........................143
           Отчет о внешних ссылках (/RX)...............................144
           Отчет о размерах модулей (/RS)..............................144
           Отчет о типах классов (/RC).................................145
           Отчет об общих именах, на которые нет ссылок (/RU)..........145
           Полный отчет (/RV)..........................................146
           Примеры использования утилиты OBJXREF.......................146

         TASM2 #5-5/Док                = 4 =

         Предупреждающие сообщения и сообщения об ошибках утилиты
          OBJXREF......................................................148
         TCREF: УТИЛИТА РАБОТЫ С ПЕРЕКРЕСТНЫМИ ССЫЛКАМИ ИСХОДНЫХ
          МОДУЛЕЙ......................................................150
           Файлы подсказок.............................................150
           Совместимость с утилитой TLINK..............................150
           Переключатели...............................................151
           Выходная информация.........................................151
         ПРИЛОЖЕНИЕ E.  СООБЩЕНИЯ ОБ ОШИБКАХ...........................153
           Информационные сообщения....................................153
         Предупреждения и сообщения об ошибках.........................154
           Arguments need types override...............................154
           Argument to operation or instruction has illegal size.......155
           Arithmetic overflow.........................................155
           ASSUME must be segment register.............................155
           Assuming segment is 32 bit..................................155
           Bad keyword in SEGMENT statement............................156
           Can't add relative quantities...............................156
           Can't address with currently ASSUMEd registers..............156
           Can't convert to pointer....................................157
           Can't emulate 8087 instruction..............................157
           Can't make variable PUBLIC..................................157
           Can't override ES segment...................................157
           Can't subtract dissimillar relative quantities..............158
           Can't use macro name in expression..........................158
           Can't use outside macro.....................................158
           Code or data emission to undeclared segment.................158
           Constant assumed to mean immediate constant.................159
           Constant too large..........................................159
           CS not correctly assumed....................................159
           CS override in protected mode...............................159
           CS unreachable from current segment.........................160
           Declaration needs name......................................160
           Directive ignored in Turbo Pascal model.....................160
           Directive not allowed inside structure definition...........161
           Duplicate dummy argument:_..................................161
           ELSE or ENDIF without IF....................................161
           Expecting offset quantity...................................162
           Expecting offset or pointer quantity........................162
           Expecting pointer type......................................162
           Expecting scalar type.......................................162
           Expecting segment or group quantity.........................163
           Extra characters on line....................................163
           Forward reference needs override............................163
           Global type doesn't match symbol type.......................163
           ID not member of structure..................................164

         TASM2 #5-5/Док                = 5 =

           Illegal forward reference...................................164
           Illegal immediate...........................................164
           Illegal indexing mode.......................................164
           Illegal instruction.........................................165
           Illegal instruction for currently selected processor(s).....165
           Illegal local argument......................................165
           Illegal local symbol prefix.................................166
           Illegal macro argument......................................166
           Illegal memory reference....................................166
           Illegal number..............................................166
           Illegal origin address......................................167
           Illegal override in structure...............................167
           Illegal override register...................................167
           Illegal radix...............................................167
           Illegal register multiplier.................................167
           Illegal segnemt address.....................................168
           Illegal use of constant.....................................168
           Illegal use of register.....................................168
           Illegal use of segment register.............................168
           Illegal USES register.......................................168
           Illegal warning ID..........................................169
           Instruction can be compacted with override..................169
           Invalid mode type...........................................169
           Invalid operand(s) to instruction...........................170
           Labels can't start with numeric character...................170
           Line is too long - truncating...............................170
           Location counter overflow...................................170
           Missing argument list.......................................170
           Missing argument of <.......................................171
           Missing argument size variable..............................171
           Missing COMM ID.............................................171
           Missing dummy argument......................................171
           Missing end quote...........................................172
           Missing macro ID............................................172
           Missing module name.........................................172
           Missing or illegal language ID..............................172
           Missing or illegal type specifier...........................173
           Missing term in list........................................173
           Missing text macro..........................................173
           Model must be specified first...............................173
           Module is pass dependent - compatibility pass was done......174
           Name must come first........................................174
           Near jump or call to different CS...........................174
           Need address or register....................................174
           Need angle brackets for structure fill......................174
           Need colon..................................................175

         TASM2 #5-5/Док                = 6 =

           Need expression.............................................175
           Need file name after INCLUDE................................175
           Need left parenthesis.......................................175
           Need pointer expression.....................................176
           Need quoted string..........................................176
           Need register in expression.................................176
           Need right angle brackets...................................176
           Need right parenthesis......................................176
           Need right square bracket...................................177
           Need stack argument.........................................177
           Need structure member name..................................177
           Not expected group or segment quantity......................177
           One non-null field allowed per union expansion..............178
           Only one startup sequence allowed...........................178
           Open conditional............................................178
           Open procedure..............................................178
           Open segment................................................179
           Open structure definition...................................179
           Operand types do not match..................................179
           Pass-dependent construction encountered.....................180
           Pointer expression need brackets............................180
           Positive count expected.....................................180
           Quantity illegal............................................181
           Record field too large......................................181
           Recursive definition not allowed for EQU....................181
           Register must be AL or AX...................................181
           Register must be DX.........................................181
           Relative jump out of range by ___ bytes.....................181
           Relative quantity illegal...................................182
           Reserved word used as symbol................................182
           Rotate count must be constant or CL.........................182
           Rotate couunt out of range..................................182
           Segment aligment not strict enough..........................183
           Segment attributes illegally redefined......................183
           Segment name is superfluous.................................183
           Smart code generation must be enabled.......................184
           String too long.............................................184
           Symbol already defined:_....................................184
           Symbol already different kind...............................184
           Symbol has no width or mask.................................184
           Symbol is not a segment or already part of group............185
           Text macro expansion exceeds maximum line length............185
           Too few operands to instruction.............................185
           Too many errors or warnings.................................185
           Too many initials values....................................186
           Too many registers in expression............................186

         TASM2 #5-5/Док                = 7 =

           Too many USES registers.....................................186
           Trailing null value assumed.................................186
           Undefined symbol............................................186
           Unexpected end of file (no END directive)...................187
           Unknown character...........................................187
           Unmatched ENDP:_............................................187
           Unmatched ENDS:_............................................187
           USE32 not allowed without .386..............................187
           User generated error........................................188
           USES has no effect without язык.............................188
           Value out of range..........................................188
         Сообщения о фатальных ошибках.................................189
           Bad switch :_...............................................189
           Can't find @file :_.........................................189
           Can't locate file...........................................189
           Error writing to listing file...............................189
           Error writing to object file................................189
           File not found..............................................189
           File was changed or deleted while assembly in progress......190
           Insufficient memory to process command line.................190
           Internal error..............................................190
           Invalid command line........................................190
           Invalid number after_.......................................190
           Maximum macro expansion exceeded............................190
           Out of hash space...........................................191
           Out of memory...............................................191
           Out of string space.........................................191
           Too many errors found.......................................191
           Unexpected end of file (no END directive)...................191

         TASM2 #5-5/Док                = 8 =


         =================================================================

                              Авторский коллектив "*.*"
                             под руководством Орлова С.Б.



                            ПРОГРАММА-СПРАВОЧНИК по системе
                        программирования ТУРБО АССЕМБЛЕР 2.0

                              СПРАВОЧНОЕ РУКОВОДСТВО

                                 #5/5 (Приложения)




                                 г.Москва, 1990 г.

         =================================================================

         TASM2 #5-5/Док                = 9 =

                                                                               
                  ПРИЛОЖЕНИЕ A. ОБОБЩЕННЫЙ СИНТАКСИС ТУРБО АССЕМБЛЕРА
         -----------------------------------------------------------------

              В этом  приложении для описания обобщенного синтаксиса выра-
         жений Турбо Ассемблера как в режиме MASM,  так и в  режиме  Ideal
         используется модифицированная форма Бэкуса-Наура.

                    Замечание: в  следующих разделах символ (...) означает
               повторение одинаковых элементов,  а м_выражение - выражение
               MASM.
                                        Лексика                                
         -----------------------------------------------------------------

            допустимая_строка

              пустой_разделитель допустимая_строка
              пунктуация допустимая_строка
              числовая_строка допустимая_строка
              строка_идентификаторов допустимая_строка
              нуль

            пустой_разделитель

              пробел пустой_разделитель
              пробел

            пробел

              Все управляющие символы, символы > 128, ' '.

            строка_идентификаторов

              символ_идентификатора строка_идентификаторов_2

            строка_идентификатора_2

              символ_идентификатора_2 строка_идентификатора_2
              нуль

            id_char

              $,_,%,?,символы_алфавита

            символ_идентификатора_2


         TASM2 #5-5/Док               = 10 =

              символы_идентификатора плюс числа

            числовая_строка

              строка_чисел
              строка_букв

            строка_чисел

              цифры алфавитно-цифровые_символы
              цифры '.' цифры экспонента
              цифры экспонента ; только в режиме MASM в
                                ; директивах DD, DQ и DT

            цифры

              цифра цифры
              цифра

            цифра

              0 - 9

            алфавитно-цифровые_символы

              цифра алфавитно-цифровые_символы

              буква алфавитно-цифровые_символы

              нуль

            буква

              символы алфавита

            экспонента

              E + цифры
              E - цифры
              E цифры
              нуль

            строка

              Строка, заключенная в кавычки


         TASM2 #5-5/Док               = 11 =

            пунктуация

              все то,  что не является пробелом,  символом_идентификатор,
               "'", '"' или цифрой.

              Символ точки  (.)  воспринимается по-разному.  В режиме MASM
         его не требуется указывать в числах с плавающей точкой, а в режи-
         ме Ideal он не может быть частью имени. В режиме MASM иногда этот
         символ используется для обозначения начала  имени идентификатора,
         а также для выбора элемента структуры.

               Правила использования символа (.) таковы:

               1. В режиме Ideal он всегда воспринимается,  как знак пунк-
                  туации.

               2. В режиме MASM он воспринимается, как первый символ иден-
                  тификатора в следующих случаях:

                  а). Когда  этот  знак является первым символом в строке,
                      или в  других  специальных  случаях,   как   внешнее
                      (EXTRN) или общедоступное (PUBLIC) имя.  Этот символ
                      присоединяется к следующему символу,  если следующий
                      символ - символ_идентификатора_2.

                  b). Если  он появляется не в начале строки или если пос-
                      ледний символ будет определен,  этот символ добавля-
                      ется к символу, следующему за ним.




         TASM2 #5-5/Док               = 12 =

                                Выражения в режиме MASM                        
         -----------------------------------------------------------------

            м_выражение_1

              'SHORT' м_выражение_1
              '.TYPE' м_выражение_1
              'SMALL' м_выражение_1 (16-ти битовое смещение
                                    (только для 80386))
              'LARGE' м_выражение_1 (16-ти битовое смещение
                                    (только для 80386))
              м_выражение_2

            м_выражение_2

              м_выражение_3 'OR' м_выражение_3 ...
              м_выражение_3 'XOR' м_выражение_3 ...
              м_выражение_3

            м_выражение_3

              м_выражение_4 'AND' м_выражение_4 ...
              м_выражение_4

            м_выражение_4

              'NOT' м_выражение_4
              м_выражение_5

            м_выражение_5

              м_выражение_6 'EQ' м_выражение_6
              м_выражение_6 'NE' м_выражение_6
              м_выражение_6 'LT' м_выражение_6
              м_выражение_6 'LE' м_выражение_6
              м_выражение_6 'GT' м_выражение_6
              м_выражение_6 'GE' м_выражение_6
              м_выражение_6

            м_выражение_6

              м_выражение_7 '+' м_выражение_7 ...
              м_выражение_7 '-' м_выражение_7 ...
              м_выражение_7

            м_выражение_7

         TASM2 #5-5/Док               = 13 =


              м_выражение_8 '' м_выражение_8 ...
              м_выражение_8 '/' м_выражение_8 ...
              м_выражение_8 'MOD' м_выражение_8 ...
              м_выражение_8 'SHR' м_выражение_8 ...
              м_выражение_8 'SHL ' м_выражение_8 ...
              м_выражение_8

            м_выражение_8

              м_выражение_9 'PTR' м_выражение_8
              м_выражение_9
              'OFFSET' м_выражение_8
              'SEG' м_выражение_8
              'TYPE' м_выражение_8
              'THIS' м_выражение_8

            м_выражение_9

              м_выражение_10 ':' м_выражение_10

            м_выражение_10

              '+' м_выражение_10
              '-' м_выражение_10
              м_выражение_11

            м_выражение_11

              'HIGH' м_выражение_11
              'LOW' м_выражение_11
              м_выражение_12

            м_выражение_12

              м_выражение_13 м_выражение_13 ... (если присутствуют '('
                                              или ']')
              м_выражение_12 м_выражение_13 '.' м_выражение_8

            м_выражение_13

              'LENGTH' идентификатор
              'SIZE' идентификатор
              'WIDTH' идентификатор
              'MASK' идентификатор
              '(' м_выражение_1 ')'

         TASM2 #5-5/Док               = 14 =

              '[' м_выражение_1 ']'
              идентификатор
              константа




         TASM2 #5-5/Док               = 15 =

                                Выражения в режиме IDEAL                       
         -----------------------------------------------------------------

            указатель

              'SMALL' указатель (16-ти битовое смещение
                                  (только для 80386))
              'LARGE' указатель (16-ти битовое смещение
                                  (только для 80386))
              тип 'PTR' указатель
              тип 'LOW' указатель
              тип 'HIGH' pointer
              тип указатель
              указатель_2

            тип

              'UNKNOWN'
              'BYTE'
              'WORD'
              'DWORD'
              'QWORD'
              'PWORD'
              'TBYTE'
              'SHORT'
              'NEAR'
              'FAR'
              идентификатор_структуры
              'TYPE' указатель

            указатель_2

              указатель_3 '.'идентификатор (операция с элементом
                                             структуры)
              указатель_3

            указатель_3

              выражение ':' указатель_3
              выражение

            выражение

              'тип_идентификатора' выражение (операция символьного типа)
              выражение2


         TASM2 #5-5/Док               = 16 =

            выражение2

              выражение_3 'OR' выражение_3 ...
              выражение_3 'XOR' выражение_3 ...
              выражение_3

            выражение_3

              выражение_4 'AND' выражение_4 ...
              выражение_4

            выражение_4

              'NOT' выражение_4
              выражение_5

            выражение_5

              выражение_6 'EQ' выражение_6 ...
              выражение_6 'NE' выражение_6 ...
              выражение_6 'LT' выражение_6 ...
              выражение_6 'LE' выражение_6 ...
              выражение_6 'GT' выражение_6 ...
              выражение_6 'GE' выражение_6 ...
              выражение_6

            выражение_6

              выражение_7 '+' выражение_7 ...
              выражение_7 '-' выражение_7 ...
              выражение_7

            выражение_7

              выражение_8 '' выражение_8 ...
              выражение_8 '/' выражение_8 ...
              выражение_8 'MOD' выражение_8 ...
              выражение_8 'SHR' выражение_8 ...
              выражение_8 'SHL ' выражение_8 ...
              выражение_8

            выражение_8

              '+' выражение_8
              '-' выражение_8
              выражение_9

         TASM2 #5-5/Док               = 17 =


            выражение_9

              'HIGH' выражение_9
              'LOW' выражение_9
              выражение_10

            м_выражение_10

              'OFFSET' указатель
              'SEG' указатель
              'LENGTH' идентификатор
              'SIZE' идентификатор
              'WIDTH' идентификатор
              'MASK' идентификатор
              идентификатор
              константа
              '(' указатель ')'
              '[' указатель ']'  (Всегда означает "содержимое чего-либо")




         TASM2 #5-5/Док               = 18 =

                                                ПРИЛОЖЕНИЕ B                   

                              СОВМЕСТИМОСТЬ
         -----------------------------------------------------------------

              Турбо Ассемблер TASM в режиме MASM хорошо совместим  с  MASM
         версии  4.0  и дополнительно поддерживает все расширения макроас-
         семблера MASM 5.0 и 5.1.  Однако 100%  совместимости добиться не-
         возможно,  так как не существует формальной спецификации на язык.
         Даже различные версии MASM несовместимы между собой.

              При работе с большинством программ вы не  будете  испытывать
         трудностей, используя  Турбо  Ассемблер  в качестве прямой замены
         MASM версий 4.0 или 5.1.  Однако TASM будет генерировать  предуп-
         реждающие сообщения или сообщения об ошибках в тех случаях, когда
         MASM этого делать не будет,  так как он не обнаруживает ошибочный
         оператор. Например MASM воспримет нормально оператор:

                ABC EQU [BP+2]
                    PUBLIC ABC

         и сгенерирует неправильный объектный файл. TASM корректно распоз-
         нает эту и множество других непонятных конструкций.

              Если у  вас возникают сложности с ассемблированием программы
         при помощи TASM,  вы  можете  попытаться  использовать  директиву
         QUIRKS. Например:

                         TASM   /JQUIRKS  MYFILE

              Данная директива может помочь при ассемблировании программы.
         Если это происходит, то в начало файла добавьте директиву QUIRKS.
         Но лучше, просмотрите это приложение и определите какой из опера-
         торов нуждается в применении директивы  QUIRKS.  Затем  исправьте
         его, чтобы обойтись без нее.

              Если вы используете некоторые возможности MASM 5.1, то  надо
         в начале файла поместить директиву MASM51.

                                                                               
              Ассемблирование в один и два прохода
         -----------------------------------------------------------------

              Обычно Турбо  Ассемблер  при  ассемблировании исходного кода
         выполняет только один проход,  в то время как MASM выполняет два.
         Это позволяет  Турбо Ассемблеру работать с большей скоростью,  но

         TASM2 #5-5/Док               = 19 =

         может привести к некоторой несовместимости при использовании опе-
         режающих ссылок и конструкций,  зависящих от прохода. В TASM вер-
         сии 2.0 введен новый параметр командной  строки  /m,  позволяющий
         задавать нужное число проходов.  Для максимальной совместимости с
         MASM должно использоваться два прохода (/m2).

              В Главе 3 "Руководства пользователя" об  этом рассказывается
         более подробно.
                                                                               
              Переменные операционной среды
         -----------------------------------------------------------------

              В соответствии  с  подходом, который используется в языковых
         продуктах фирмы Borland, TASM не использует переменные среды  для
         управления параметрами,  используемыми по умолчанию. Вместо этого
         вы можете поместить параметры в файл конфигурации,  и  затем  ис-
         пользовать различные файлы конфигурации для различных приложений.
         (См. Главу 3 "Руководства пользователя").

              Если для настройки программы MASM вы использовали переменные
         среды  INCLUDE и MASM, то для TASM необходимо создать файл конфи-
         гурации. Все параметры,  заданные с помощью переменной операцион-
         ной среды MASM,  можно поместить в файл конфигурации. Любые ката-
         логи,  определяемые  ранее при помощи переменной INCLUDE,  должны
         быть помещены в файл  конфигурации  при  помощи  опции  командной
         строки /I.

                                                                               
              Формат чисел с плавающей точкой фирмы Microsoft
         -----------------------------------------------------------------

              Старые версии MASM по умолчанию генерируют числа с плавающей
         точкой в формате,  несовместимым с форматом IEEE. MASM версии 5.1
         по  умолчанию  генерирует  числа  с плавающей точкой по стандарту
         IEEE, а для совместимости с ранними версиями в его состав введена
         директива .MSFLOAT.

              Турбо Ассемблер  TASM не поддерживает ни старый формат чисел
         с плавающей точкой, ни директиву .MSFLOAT.

                                                                               
              Режим QUIRKS
         -----------------------------------------------------------------

              Некоторые средства MASM весьма проблематичны,  и поэтому они
         не включены в режим MASM программы TASM.  Однако программисты лю-

         TASM2 #5-5/Док               = 20 =

         бят иногда получать выгоду из некоторых  сомнительных  возможнос-
         тей.  В связи с этим,  в TASM предусмотрен режим QUIRKS,  который
         эмулирует потенциально проблематичные возможности MASM.  Этот ре-
         жим  вы  можете разрешить либо при помощи ключевого слова QUIRKS,
         помещенного в исходный файл,  либо  при  помощи  опции  командной
         строки /JQUIRKS.

              При ассемблировании приведенных ниже конструкций TASM  будет
         генерировать сообщения об ошибке, если не разрешен режим QUIRKS.

                                                                               
              Пересылка байта в сегментный регистр и из него
         -----------------------------------------------------------------

              Макроассемблер MASM не проверяет размер операнда  при  пере-
         сылке содержимого сегментного регистра в память, а также из памя-
         ти в сегментный регистр.  Например, MASM нормально воспримет сле-
         дующие строки:

                 SEGVAL DB  ?
                 USEFUL DB  ?
                    mov segval,es    ; переопределяет часть ""USERFUL"

              Это явная ошибка программирования. Программа работает только
         потому, что ее поведение не  зависит  от  значения  поля  USEFUL.
         Вместо  того,  чтобы  вводить  режим QUIRKS, лучше переопределить
         SEGVAL как DW.

                                                                               
           Ошибочные переходы ближнего типа к дальней метке или процедуре
         -----------------------------------------------------------------

              MASM не  будет  генерировать  команду перехода дальнего типа
         (FAR) на метку либо процедуру, если она расположена в одном и том
         же  с командой перехода сегменте (даже при явном на то указании):

                 CODE SEGMENT
                      JMP  ABC
                      JMP  FAR PTR ABC ; не будет генерировать FAR JMP
                 ABC  LABEL FAR
                 CODE ENDS

              TASM будет генерировать инструкцию перехода  (JMP)  дальнего
         типа,  когда вы явно укажете на то, что она должна передавать уп-
         равление на дальнюю метку или процедуру.  Если вы  хотите,  чтобы
         TASM поступал также как и MASM,  то используйте директиву QUIRKS.

         TASM2 #5-5/Док               = 21 =


                                                                               
              Потеря информации о типе в директивах = и EQU
         -----------------------------------------------------------------

              Рассмотрим следующий фрагмент программы:

                X DW 0
                Y = OFFSET X
                    mov ax,Y

              Макроассемблер MASM   будет   генерировать   инструкцию  MOV
         AX,[X], а TASM - MOV AX,OFFSET X. Это происходит потому, что MASM
         некорректно сохраняет всю информацию, описывающую выражение спра-
         ва от директивы =.

              То же  самое  происходит и тогда, когда при помощи директивы
         EQU вы определяете символ, равный значению выражения.

                                                                               
              Проверка выравнивания сегмента
         -----------------------------------------------------------------

              MASM позволяет c помощью директивы ALIGN определить выравни-
         вание сегмента более строгое, чем то, которое определено при опи-
         сании сегмента. Например:

              CODE SEGMENT WORD
                   ALIGN 4 ; выравнивание сегмента только на границу слова
              CODE ENDS

              Это опасно, так как компоновщик может отменить действия этой
         директивы при комбинировании этой части сегмента CODE  с  другими
         сегментами с таким же именем в других модулях.  Даже после этого,
         вы не можете быть гарантированы от того, что часть сегмента в ва-
         шем модуле будет выравнена на границу, отличную от границы слова.



         TASM2 #5-5/Док               = 22 =

                      Арифметические и логические инструкции для работы        
                            непосредственно со знаковыми числами
         -----------------------------------------------------------------

              MASM версии  4.0  производит расширение знака для непосредс-
         твенных операндов только в арифметических  операциях.  Турбо  Ас-
         семблер TASM,  если только он не работает в режиме QUIRKS, произ-
         водит расширение  знака  для  непосредственных  операндов  и  для
         логических инструкций. Это приводит к уменьшению размера инструк-
         ции и ускорению ее выполнения,  но изменяют размер сегмента кода,
         содержащего эти конструкции, что может вызвать проблемы при само-
         модифицируемом коде, а также при коде, в котором используется его
         размер. Приведенный ниже пример демонстрирует инструкцию, которую
         MASM и TASM ассемблируют одинаково,  а также инструкцию,  которую
         TASM генерирует правильно, а EMASM - нет:

                ADD ax,-1      ; MASM и TASM производят расширение знака
                XOR cx,0FFFFh  ; MASM будет использовать непосредственно
                               ; слово, а TASM производит расширение знака

              Здесь MASM  версии 4.0 будет генерировать последовательность
         байт 81 F1 FF FF для инструкции XOR,  а TASM - 83 F1 FF. Если вам
         необходимо генерировать последовательность байт,  как в MASM,  то
         используйте режим QUIRKS.

                                  Средства MASM версии 5.1                     
         -----------------------------------------------------------------

              Некоторые возможности, введенные в MASM версии 5.1, доступны
         при использовании Турбо Ассемблера TASM.  Другие  средства  могут
         быть  разрешены  директивой MASM51.  Вначале ассемблирования TASM
         находится в режиме MASM и использование расширений MASM 5.1  зап-
         рещено.  Это  аналогично  запуску TASM с использованием директивы
         MASM или NOMASM51.

              Каждое из  расширений,  приведенных ниже, подробно описано в
         главе 2 "Руководства пользователя" или в Главе 3 этой книги.

              Непосредственно доступны следующие расширения MASM 5.1:

             - параметры и локальные аргументы в директиве PROC;
             - расширение операции .TYPE;
             - расширение директивы COMM;
             - директива  .CODE  устанавливает CS:ASSUME для текущего сег-
               мента;

         TASM2 #5-5/Док               = 23 =

             - директива .MODEL поддерживает языки высокого уровня;
             - просмотр всех опций командной строки (/LA);
             - дополнительная отладочная  информация в директивах DW, DD и
               DF;
             - семейство директив ELSEIF;
             - директивы @Cpu и @WordSize;
             - оператор выражения в макрокомандах (%);
             - расширенная отладочная информация для директив DW, DD и DF.

              Следующие расширения доступны  при  использовании  директивы
         MASM51:

             - директивы SUBSTR, CATSTR, SIZESTR и INSTR;
             - продолжение строки при помощи символа (/);
             - альтернативный синтаксис аргументов для директивы LOCAL.

              Следующие расширения  доступны  при  использовании директивы
         MASM51 и QUIRKS:

             - локальные метки определяются с символами @@,  а  ссылки  на
               них при помощи @F и @B;
             - переопределение переменных внутри процедур;
             - имена процедур  языка C и имена всех общих переменных начи-
               наются с символа (_).

                           Средства режима /QUIRKS MASM версии 5.1             
         -----------------------------------------------------------------

              Поскольку некоторые средства MASM 5.1 отрицательно влияют на
         отдельные средства  Турбо Ассемблера,  в Турбо Ассемблере предус-
         мотрена альтернатива,  которая позволяет получить все возможности
         MASM версии 5.1.

              Перечислим кратко  то,  что охватывается различными режимами
         работы TASM:

              Режим QUIRKS:

              1. Позволяет генерировать  дальние  переходы,  как  переходы
         ближнего или короткого типа  (если определен CS).

              2. Позволяет  в бинарной операции определять размер инструк-
         ции в бинарной операции исключительно через регистр (если он при-
         сутствует).


         TASM2 #5-5/Док               = 24 =

              3. Уничтожает информацию OFFSET, переопределение сегментов и
         т.д. в присваиваниях по директиве = или EQU.

              4. Позволяет использовать в директивах EQU текстовые присва-
         ивания в выражениях с операцией PTR или :.

              5. Запрещает директиву UNION.

              6. Допускает переопределение директивы GLOBAL.

              Режим MASM51:

              1. Разрешает Instr,  Catstr,  Substr,  Sizestr и продолжение
         строки \.

              2. Позволяет использовать EQU с ключевым словом  TEXT вместо
         ALIAS.

              3. Не  отбрасывает более предшествующие пробелы в макроаргу-
         ментах текстовой макрокоманды.

              Режимы MASM51 и QUIRKS:

              В этот перечень можно включить все то,  что указывается  для
         режимов QUIRKS и MASM51, а также следующее:

              1. Разрешаются локальные метки @@F и @@B.

              2. В расширенных моделях именам процедур автоматически прис-
         ваивается тип PUBLIC.

              3. Ближние метки,  определенные в одних процедурах, допуска-
         ется переопределять в других процедурах.

              4. С  помощью  операции ::  можно определить идентификаторы,
         которые будут доступны вне текущей процедуры.

              5. Старые символы продолжения строки работают также,  как  в
         режиме MASM51 (если они указываются в конце строки).

                                    Совместимость с QUASM                      
         ----------------------------------------------------------------

              В Турбо Ассемблере версии 2.0 имеются новые и модифицирован-
         ные директивы  для  поддержки  исходного  кода  MASM  версии  5.2

         TASM2 #5-5/Док               = 25 =

         (QUAM).

              1. Директивы .STARTUP  и  STARTUPCODE  генерируют  постоянно
         действующий код инициализации для конкретной модели. При этом оп-
         ределяется также метка ближнего типа @Startup,  а в операторе END
         в конце  данного  модуля  генерируется  эквивалентная  метка  END
         @Startup. Примечание:  в режиме Ideal доступна  только  директива
         STARTUPCODE.

              2. Директивы .MODEL и MODEL позволяют теперь выбирать третье
         поле в директиве .MODEL для определения  связи  стека  с  DGROUP:
         NEARSTACK или FARSTACK. Например:

                 .MODEL SMALL, C, FARSTACK

         задает, что  стек не будет включен в DGROUP.  Эта возможность уже
         реализована в TASM с помощью модификаторов модели одного  и  того
         же имени.  Дополнительное  поле предусматривается только для сов-
         местимости с MASM.

               3. @Model представляет собой  предопределенный  идентифика-
         тор, который  отражает  текущую модель:  0 = сверхмалая,  1 = ма-
         лая, ... 5 = сверхбольшая.



         TASM2 #5-5/Док               = 26 =

                                                                               
                               ПРИЛОЖЕНИЕ C

                    ОСОБЕННОСТИ  ТУРБО  АССЕМБЛЕРА
         -----------------------------------------------------------------

              Наряду с высокой совместимостью с MASM, Турбо Ассемблер TASM
         имеет ряд расширений, которые вы можете использовать вместе с ти-
         пичными операторами MASM.  Эти расширения могут быть использованы
         как в режиме MASM,  так и в улучшенной режиме Ideal (См. Главу 11
         "Руководства пользователя").  Ниже приводится описание каждого из
         расширений и указывается,  где в руководстве об этом можно узнать
         подробнее.
                                                                               
              Расширенный синтаксис командной строки
         -----------------------------------------------------------------

              В Турбо  Ассемблере  существенно улучшен синтаксис командной
         строки (по сравнению с MASM).  Например, вы можете определить для
         ассемблирования несколько файлов, вводя их имена последовательно,
         или разделяя их специальными символами ? или *).  Возможно  также
         группирование  файлов  таким  образом,  что  для трансляции одной
         группы будет установлена одна группа параметров, а для трансляции
         другой группы файлов - другая.  Для полного  описания  параметров
         командной строки см. в Главе 3 "Руководства пользователя".



         TASM2 #5-5/Док               = 27 =

                                                                               
              Директива GLOBAL
         -----------------------------------------------------------------

              Директива GLOBAL позволяет вам определять переменную, проме-
         жуточную  между  EXTRN  и PUBLIC. Вы можете поместить переменные,
         определенные при помощи этой директивы в  начало  файла,  который
         включает  все  исходные  модули и затем определить данные в одном
         модуле. Это позволит вам  обойтись  без  использования  директивы
         COMM. В разделе "Директива GLOBAL" в Главе 6 "Руководства пользо-
         вателя" показывается, как использовать эту директиву.
                                                                               
              Директива PUBLICDDL
         -----------------------------------------------------------------

              Данная директива позволяет вам определить метки и процедуры,
         как динамические точки входа при компоновке,  а также сделать  их
         доступными для других модулей, которые позволяют вам на Ассембле-
         ре строить библиотеки для динамической компоновки.  Подробнее  об
         этой директиве  рассказывается  в  Главе 3 "Справочного руководс-
         тва".
                                                                               
              Расширение директивы COMM
         -----------------------------------------------------------------

              Директива COMM  теперь расширена и позволяет выбирать размер
         элемента массива и счетчик элемента массива для  общих переменных
         типа FAR  независимо  друг  от друга.  Более подробно о директиве
         COMM рассказывается в Главе 3 "Справочного руководства".
                                                                               
              Локальные идентификаторы
         -----------------------------------------------------------------

              Директивы LOCALS  и  NOLOCALS управляют размещением в тексте
         локальных идентификаторов,  то есть идентификаторов, обычно начи-
         нающихся со знаков @@. Описание этих директив приведено в Главе 3
         данного руководства.
                                                                               
              Расширение инструкций условных переходов
         -----------------------------------------------------------------

              Директивы JUMPS и NOJUMPS  управляют  "расширением"  области
         передачи управления инструкциями условных переходов. Они позволя-
         ют вам передавать управление этими инструкциями  без  ограничения
         внутри сегмента.  Полное описания этих директив приведено в Главе
         3 "Руководства пользователя".


         TASM2 #5-5/Док               = 28 =

                                                                               
              Режим IDEAL
         -----------------------------------------------------------------

              Режим Ideal  (или  улучшенный  режим)  Турбо Ассемблера TASM
         предоставляет вам новый,  более рациональный путь конструирования
         выражений и операндов в инструкциях.  Запомнив два простых прави-
         ла, вы сможете более гибко управлять операндами  инструкций.  Для
         ознакомления  с описанием этого режима см.  Главу 11 "Руководства
         пользователя".
                                                                               
              Вложенные директивы UNION/STRUC
         -----------------------------------------------------------------

              В Турбо Ассемблере вы можете использовать вложенные структу-
         ры, а также их комбинации при помощи директивы UNION.  В разделе,
         озаглавленном "Директива STRUC",  в Главе 9  "Руководства пользо-
         вателя" показывает,  как вы можете  использовать  эту  директиву.
         Глава 3 "Справочного руководства" полностью описывается  как  ди-
         ректива STRUC, так и UNION.

                                                                               
              Директивы EMUL И NOEMUL
         -----------------------------------------------------------------

              При помощи этих директив вы можете управлять размещением ин-
         струкций сопроцессора 80387 в объектном модуле.
                                                                               
              Префиксы переопределения сегмента
         -----------------------------------------------------------------

              Турбо Ассемблер  TASM позволяет непосредственно в генерируе-
         мой инструкции переопределять сегмент.  Это достигается  при  ис-
         пользовании префиксов:  SEGCS, SEGDS, SEGES, SEGSS или SEGGS. Эти
         префиксы аналогичны префиксам REP и LOCK.

              Об этих префиксах вы можете узнать из раздела "Префиксы  пе-
         реопределения сегмента" в Главе 9 "Руководства пользователя".




         TASM2 #5-5/Док               = 29 =

                                                                               
              Постоянные сегменты
         -----------------------------------------------------------------

              Турбо Ассемблер TASM  позволяет  вам  использовать  значение
         константы  в  любое  время,  когда известно значение указателя на
         сегмент. Например:

                  JMP  FAR PTR 0FFFFh:0
              LOWDATA SEGMENT AT 0
                      ASSUME DS:LOWDATA+40h
                      mov    ax,DS:[3F]
              LOWDATA ENDS

              Полное описание этой возможности содержится в  разделе  "Ди-
         ректива SEGMENT" Главы 9 "Руководства пользователя".
                                                                               
              Расширенная инструкция CALL
         -----------------------------------------------------------------

              Инструкция CALL в Турбо Ассемблере расширена и позволяет вы-
         зывать независимым от языка способом подпрограммы на языке  высо-
         кого уровня. В любой инструкции CALL можно теперь задавать язык и
         список аргументов вызываемой подпрограммы.  Турбо Ассемблер авто-
         матически генерирует  необходимую  установку стека и код очистки,
         необходимые для передачи аргументов в подпрограмму  на  соответс-
         твующем языке  высокого  уровня.  Примеры  использования  данного
         средства в Турбо языках  содержатся в Главах 7 и  8  "Руководства
         пользователя".

                                                                               
              Расширенные инструкции PUSH и POP
         -----------------------------------------------------------------

              Инструкции PUSH и POP расширены в Турбо Ассемблере таким об-
         разом, что  в них можно указывать более одного аргумента.  Напри-
         мер:

                 push   ax dx  ; эквивалентно паре инструкций push
                 pop    dx ax  ; эквивалентно паре инструкций pop

              Кроме того, в инструкции PUSH допускается использовать аргу-
         менты-константы (даже при генерации кода  для  процессора  8086).
         Такие инструкции заменяются в объектном коде 10-байтовой последо-
         вательностью, эмулирующей инструкцию PUSH с непосредственным зна-
         чением процессоров 80186/286/386.


         TASM2 #5-5/Док               = 30 =

                           Расширения, касающиеся конкретного языка            
         -----------------------------------------------------------------

              В Турбо Ассемблере расширены операторы  CALL,  COMM,  EXTRN,
         GLOBAL, .MODEL, PROC и PUBLIC. Это позволяет определять и исполь-
         зовать подпрограммы и идентификаторы языка высокого уровня  неза-
         висимым от  языка  способом.  Эти расширения позволяют вам писать
         общий код,  который автоматически модифицируется Турбо  Ассембле-
         ром согласно правилам заданного вами языка.  Например,  вы можете
         написать подпрограмму, воспринимающую несколько параметров, пора-
         ботать с ними,  а затем, перед возвратом их в вызывающую програм-
         му, вызвать подпрограмму на языке высокого уровня.  Обычно подоб-
         ные подпрограммы   приходится   приспосабливать  под  соглашения,
         использующиеся в конкретном языке,  включая специальный код,  вы-
         полняющий установку стека на входе процедуры, правильный доступ к
         параметрам в стеке, установку и очистку стека при вызове подпрог-
         раммы на  языке  высокого  уровня,  а также очистку стека,  когда
         подпрограмма возвращает управление в вызывающую программу.  Труд-
         ности могли  встретиться  также  из-за соглашений по наименованию
         идентификаторов  (например, в языке Си перед именами всех иденти-
         фикаторов требуется указывать подчеркивание). Примеры использова-
         ния данных средств содержатся в Главе 7 и  Главе  8  "Руководства
         пользователя".

              Теперь Турбо  Ассемблер  позволяет  использовать расширенные
         операторы и выполняет за вас все эти функции.  Вам  нужно  только
         задать, соглашения  какого языка будут использоваться в каждом из
         операторов. Это позволяет вам чередовать и  сравнивать соглашения
         по вызову на процедурной основе.  В операторах PROC и .MODEL пре-
         дусмотрены дальнейшие   расширения,   облегчающие   использование
         программирования, независимого от языка.




         TASM2 #5-5/Док               = 31 =

                                                                               
              Расширенная инструкция LOOP в режиме процессора 80386
         -----------------------------------------------------------------

              При написании программ для микропроцессора 80386 TASM позво-
         ляет  использовать  в директиве LOOP в качестве счетчика либо ре-
         гистр CX, либо ECX.

              Описание использования этой инструкции приводится  в разделе
         "Новые версии LOOP и JCXZ" в Главе 10 "Руководства пользователя".

                                                                               
              Расширенное управление листингом
         -----------------------------------------------------------------

              В Турбо Ассемблере TASM имеются большие возможности  по  уп-
         равлению как содержимым, так и форматом листинга. Вы можете уста-
         навливать ширину страницы листинга,  сохранять в стеке и  восста-
         навливать из него режимы управления листингом,  включать исходные
         файлы при помощи директивы INCLUDE а также делать еще много  дру-
         гого.

              Все эти возможности описаны в Главе 5 "Руководства пользова-
         теля".

                                                                               
              Альтернативные директивы
         -----------------------------------------------------------------

              Турбо Ассемблер  TASM использует альтернативные названия для
         некоторых директив, особенно для тех, которые начинаются со знака
         (.).  Все  альтернативные директивы начинаются со знака (%).  Все
         альтернативные директивы управления процессором начинаются с бук-
         вы P.

              В Главе  3  данного руководства приведен полный перечень ди-
         ректив, которые поддерживает TASM.




         TASM2 #5-5/Док               = 32 =

                                                                               
              Предопределенные переменные
         -----------------------------------------------------------------

              TASM определяет ряд переменных, к которым  вы  можете  обра-
         щаться из  исходного  файла.  Это  такие переменные,  как ??DATE,
         ??TIME, ??FILENAME  и  ??VERSION,  в дополнение к тем переменным,
         которые присутствуют в MASM 5.0.

              Для знакомства с описанием этих переменных см. раздел " Пре-
         допределенные переменные" Главы 1 "Справочного руководства".
                                  Расширения MASM 5.0 и 5.1                    
         -----------------------------------------------------------------

              Турбо Ассемблер TASM обладает всеми расширениями, свойствен-
         ными MASM 5.0 и 5.1. Если вы не знакомы с этими расширениями, ни-
         же приводится их список с указанием, где с ними можно ознакомить-
         ся:

              - Поддержка микропроцессора 80386:
                (См. раздел "80386" в Главе  10  "Руководства  пользовате-
                ля".)

              - Директивы управления сегментами:
                (См. раздел "Директивы управления сегментами и  типы  сег-
                ментов для микропроцессора 80386".)

              - Присваивание строк:
                (См. раздел "Использование директивы EQU" в Главе  9  "Ру-
                ководства пользователя".)

              - Инструкции RETF и RETN:
                (См. раздел "Как работают подпрограммы" в Главе  5  "Руко-
                водства пользователя".)

              - Общие переменные:
                (См. описание директивы COMM в Главе 3 "Справочного  руко-
                водства".)

              - Определение подключаемых библиотек:
                (См. директиву INCLUDE в Главе 3 "Справочного руководства".)

              - Более гибкое определение структур:
                (См. раздел "Структуры и объединения" в Главе 10 "Руковод-
                ства пользователя".)


         TASM2 #5-5/Док               = 33 =

              - Предопределенные переменные:
                (См. раздел "Директивы управления сегментами" в Главе 5, а
                также Главу 10 "Руководства пользователя".)



         TASM2 #5-5/Док               = 34 =

                                                                               
              Расширенное управление директивами SHR и SHL
         -----------------------------------------------------------------

              Макроассемблер MASM  не  позволяет использовать в выражениях
         директив SHL и SHR с отрицательным счетчиком сдвига.  TASM позво-
         ляет это делать, при этом операнд будет сдвинут в противоположную
         сторону. Например, 16SHL -2 эквивалентно 16SHL 2.
                                                                               
              Возможности многопроходной обработки
         -----------------------------------------------------------------

              Для совместимости с MASM, когда используются некоторые зави-
         симые от проходов конструкции или для удаления добавленных  в код
         из-за опережающих  ссылок  инструкций NOP,  в Турбо Ассемблер при
         ассемблировании вашего кода может выполнять более одного прохода.
         Это средство  разрешается  с  помощью  параметра командной строки
         /m#, где # задает максимально допустимое число  проходов  (полное
         описание данной  возможности  содержится  в Главе 13 "Руководства
         пользователя").



         TASM2 #5-5/Док               = 35 =

                             ПРИЛОЖЕНИЕ D. УТИЛИТЫ  ТУРБО  АССЕМБЛЕРА          
         -----------------------------------------------------------------

              Турбо Ассемблер TASM предоставляет вам пять мощных  автоном-
         ных  утилит.  Вы можете использовать их для файлов TASM,  а также
         для любых других файлов.

              Это такие утилиты, как:

            - MAKE  (включая утилиту TOUCH; автономный менеджер программ);
            - TLINK (редактор связей, компоновщик);
            - TLIB  (библиотекарь);
            - GREP  (утилита поиска текста в файлах);
            - OBJXREF (утилита  для работы с перекрестными ссылками в объ-
              ектных модулях);
            - TCREF (утилита для работы с перекрестными ссылками).

              В этом приложении приводится описание каждой утилиты, а так-
         же порядок работы с ней. Описание утилит TCREF и OBJREF содержит-
         ся в файле на дистрибутивном диске.  Ознакомьтесь с его  содержи-
         мом, так  как  в  нем  могут описываться последние изменения,  не
         включенные в данную документацию.



         TASM2 #5-5/Док               = 36 =

                                      АВТОНОМНАЯ УТИЛИТА MAKE                  
         -----------------------------------------------------------------

              Автономная утилита  MAKE  (менеджер  программ) предназначена
         для помощи при создании сложных программ,  состоящих из  большого
         количества модулей. Эта утилита аналогична программе операционной
         системы UNIX с тем же именем.

              MAKE представляет  собой  интеллектуальный программный адми-
         нистратор,  который при задании определенных команд выполнит  все
         необходимое для обновления программы.  В действительности возмож-
         ности утилиты MAKE значительно шире.  Эта утилита создает резерв-
         ные копии, удаляет файлы из различных подкаталогов и даже автома-
         тически запускает ваши программы, внося изменения в файлы данных,
         которые они используют.  По мере использования MAKE вы обнаружите
         и другие способы использования этой утилиты для разработки  прог-
         рамм.

              Если вы забудете перекомпилировать  измененный  модуль,  это
         может привести к серьезным ошибкам. С другой стороны,   перекомпи-
         лировать для надежности все модули было бы пустой тратой времени.

              Утилита MAKE позволяет решить эту проблему. Вы должны соста-
         вить для нее описание,  как нужно обрабатывать исходные и объект-
         ные файлы вашей программы  для  получения  конечного  результата.
         MAKE анализирует это описание и даты ваших файлов и выполняет все
         необходимые действия для создания обновленной  версии.  При  этом
         она вызывает нужные компиляторы,  ассемблеры, компоновщики у ути-
         литы, но только те, которые необходимы для обновления программы.

              Преимущество использования утилиты  MAKE  выходит  за  рамки
         прикладных программ. Вы можете использовать ее для управления лю-
         бым процессом,  при котором выбираются и обрабатываются  файлы  с
         заданными именами  и создается конечный продукт.  Некоторые общие
         примеры включают в себя обработку текстов, автоматическую архиви-
         зацию, сортировку  файлов по расширению и удаление временных фай-
         лов из вашего каталога.



         TASM2 #5-5/Док               = 37 =

                               Как работает утилита MAKE                       
         -----------------------------------------------------------------

              При создании обновленной версии вашей программы утилита MAKE
         выполняет следующие функции:

              - Считывает специальный файл (который называется формирующим
         файлом), предварительно вами созданный.  Этот файл указывает ути-
         лите MAKE,  какие объектные и библиотечные файлы нужно  скомпоно-
         вать для  получения  вашего выполняемого файла,  и какие исходные
         файлы и файлы заголовков нужно компилировать для создания каждого
         объектного файла.

              - Проверяет дату и время создания каждого объектного файла и
                сравнивает их с текущей датой и временем,  а также датой и
                временем каждого исходного файла и файла заголовка, от ко-
                торых они зависят.  Если какой либо из них  "старее",  чем
                объектный файл,  то MAKE знает, что этот исходный файл мо-
                дифицирован,  и что исходный файл нужно перекомпилировать.

              - Для перекомпиляции исходного файла вызывается компилятор.

              - После проверки всех зависимостей объектного файла проверя-
                ется  дата и время создания каждого объектного файла.  Они
                сравниваются с датой и временем создания выполняемого фай-
                ла.

              - Если какой-либо из объектных  файлов  "старее",  чем  файл
                .EXE, то вызывается компоновщик для нового создания выпол-
                няемого файла.

                    Предупреждение: Утилита  MAKE  полностью полагается на
                ту дату и время создания,  которые проставляет для каждого
                файла DOS.  Это означает, что для того, чтобы утилита MAKE
                выполняла свои функции, дата и время в вашей системе долж-
                ны устанавливаться корректно.  Если вы работаете на IMB PC
                AT или PS/2,  убедитесь, что аккумулятор (часов) работает.
                При слабом заряде аккумулятора значения даты и времени мо-
                гут быть потеряны,  что может привести к  сбоям  в  работе
                утилиты MAKE.

                    Обычные компьютеры  IBM PC и многие совместимые с ними
               не поставляются со встроенными часами и календарем. Если вы
               работаете на такой системе, убедитесь перед началом работы,
               что дата и время установлены правильно (для этого использу-
               ются команды DOS DATE и TIME).

         TASM2 #5-5/Док               = 38 =

                                  Запуск утилиты MAKE                          
         -----------------------------------------------------------------

              Для запуска утилиты MAKE введите команду  make  в  ответ  на
         подсказку DOS. При этом утилита MAKE ищет файл с именем MAKEFILE.
         Если она не может найти данный файл,  то выполняется поиск  файла
         MAKEFILE.MAK. Если  она также не может найти данный файл или файл
         BUILTINS.MAK, то завершает работу с сообщением об ошибке.

              Но как быть,  если вы хотите использовать  файлы  с  другими
         именами? Их можно указать с помощью параметра -f:

                 make -fmyfile.mak

              Общий синтаксис вызова утилиты MAKE следующий:

                 make параметр параметр ... целевой_файл целевой_файл ...

         где "параметр" представляет собой параметр утилиты MAKE (см.  да-
         лее), а "целевой файл" - это имя целевого файла, который требует-
         ся обработать в соответствии с явными правилами.

              Приведем пример правил синтаксиса утилиты MAKE:

              - За словом make следует пробел, затем список параметров.

              - Параметры должны отделяться друг от друга пробелами.  Ука-
                зываться они могут в любом порядке.  Можно задавать  любое
                число параметров  (насколько  хватает  места  в  командной
                строке).  За всеми параметрами,  не  определяющими  строку
                (как, например, -s или -a) может указываться знак + или -.
                Это указывает, хотите вы "включить" или "выключить" данный
                параметр.

              - После списка всех параметров следует пробел, а затем необя-
                зательный список целевых файлов.

              - Целевые файлы должны также отделяться друг от друга пробе-
                лами. Утилита MAKE обрабатывает целевые файлы в том поряд-
                ке, в каком они указываются, перекомпилирую в случае необ-
                ходимости их содержимое.

              Если целевой файлы в командной строке не указываются, утили-
         та MAKE  использует  первый  целевой  файл,  указанный  в   явном
         правиле. Если  в  командной строке указаны один или более целевых
         файлов, то при необходимости они будут сформированы.

         TASM2 #5-5/Док               = 39 =


              Ниже приведены примеры вызова утилиты MAKE:

                 make -n -fstars.mak
                 make -s
                 make -Iinclude -DMDL = compact



         TASM2 #5-5/Док               = 40 =

                                                                               
         Как прервать выполнение утилиты MAKE
         -----------------------------------------------------------------

              Утилита MAKE прервет выполнение,  если какая-либо ее команда
         завершилась нажатием Ctrl-Break.  Таким образом, выполнение теку-
         щей команды и саму программу MAKE можно прервать по Ctrl-C.
                                    Файл BULTINS.MAK                           
         -----------------------------------------------------------------

              При использовании  обслуживающей программы МAКЕ вы часто об-
         наруживаете, что имеются макроопределения и правила (обычно неяв-
         ные правила), которые используются много раз. Есть три способа их
         обработки.

              Файл BUILTINS.MAK  предназначается  для любых правил (обычно
         неявных правил) или макроопределений,  которые будут служить  для
         общего пользования в файлах в любом месте на вашей вычислительной
         машине.

              Наличие файла BUILTINS.MAK не  является  обязательным.  Если
         обслуживающая  программа  МАКЕ находит файл BUILTINS.MAK,  то она
         интерпретирует его первым.  Если обслуживающая программа МAКЕ  не
         может найти файла BUILTINS.MAK, она приступает к непосредственно-
         му интерпретированию файла MAKEFILE (или любого формирующего фай-
         ла, который вы укажете).

              С часто используемыми правилами и макрокомандами можно рабо-
         тать тремя способами:

              - Во-первых, вы можете поместить их в каждый создаваемый ва-
                ми формирующий файл.
              - Во-вторых, вы можете поместить все их в один файл и в каж-
                дом создаваемом вами формирующем файле использовать дирек-
                тиву  !include  (более  подробно о директивах мы расскажем
                дальше).

              - В третьих, вы можете поместить их все в файл BUILTIN.MAK.

              Таким образом,  в данный файл вы  можете  помещать  наиболее
         часто используемые макроопределения и правила. При каждом запуске
         утилита MAKE ищет файл BULTINS.MAK;  если данный файл существует,
         MAKE читает его прежде,  чем MAKEFILE. Если утилита MAKE не может
         найти файл BUILKTIN.MAK,  она обрабатывает файл MAKEFILE (или тот
         формирующий файл, который вы задали).


         TASM2 #5-5/Док               = 41 =

              Поиск файла BULTINS.MAK осуществляется  в  текущем  каталоге
         Если утилита MAKE не находит его в текущем каталоге, и вы работа-
         ете под управлением DOS версии 3.х,  то поиск файла выполняется в
         том каталоге, откуда запущена утилита MAKE.EXE.

              Утилита MAKE всегда выполняет поиск формирующего файла толь-
         ко в текущем каталоге.  Этот файл содержит правила для построения
         конкретного файла выполняемой  программы.  Два  описанных  файла
         имеют идентичные синтаксические правила.

              Утилита MAKE ищет также в текущем каталоге включаемые файлы,
         указанные в директиве !include (более подробно об этом  рассказы-
         вается далее). Если вы используете параметр -I, то поиск выполня-
         ется также в каталоге, заданном в данном параметре.
                                    Небольшой пример                           
         -----------------------------------------------------------------

              Допустим, вы пишете несколько программ, осуществляющих вывод
         на экран дисплея информации о соседних  звездных  системах.  Одна
         программа, GETSTARS.ASM, считывает в текстовый файл список звезд-
         ных  систем,  осуществляет некоторую его обработку и создает файл
         двоичных данных, содержащий полученную информацию.

              Программа GETSTARS.ASM  использует  некоторые  макрокоманды,
         расположенные  в  STARDEFS.INC,  и  подпрограммы,  находящиеся  в
         STARLIB. ASM (объявленные в STARLIB.INC).

              GETSTARS.ASM использует  три модуля: GSPARSE.ASM, GSCOMP.ASM
         и GETSTARS.ASM. Первые два  файла,  GSPARSE  и  GSCOMP,  содержат
         включаемые файлы  (GSPARSE.INC  и   GSCOMP.INC).   Третий   файл,
         GETSTARS. ASM, является основным файлом программы.

              Из этих  файлов  только GSCOMP.ASM и GETSTARS.ASM используют
         подпрограммы из STARLIB.ASM.



         TASM2 #5-5/Док               = 42 =

              Для каждого файла требуются следующие включаемые файлы:

              --------------------------------------------------
              Имя файла                Включаемые файлы
              --------------------------------------------------
              STARLIB.ASM              нет
              GSPARSE.ASM              STARDEFS.INC
              GSCOMP.ASM               STARDEFS.INC,STARLIB.INC
              GETSTARS.ASM             STARDEFS.INC,STARLIB.INC,
                                       GSPARSE.INC,GSCOMP.INC
              --------------------------------------------------

              Для того,  чтобы создать файл GETSTARS.EXE  (средняя  модель
         памяти), необходимо ввести следующие команды:

         tasm /t /ml /s starlib
         tasm /t /ml /s gsparse
         tasm /t /ml /s gscomp
         tasm /t /ml /s getstars
         tlink starlib gsparse gscomp getstars,getstars, lib\io lib\math

              Отметим следующие зависимости:

            - файлы GSPARSE,GSCOMP и  GETSTARS  зависят  от  STARDEFS.INC.
              Другими словами, если вы внесли изменения в STARDEFS.INC, то
              необходимо повторно транслировать эти 3 файла;

            - аналогично, любые изменения в STARLIB.INC приводят к необхо-
              димости повторной трансляции GSCOMP и GETSTARS;

            - изменения в GSPARSE.INC приводят к  необходимости  повторной
              трансляции файлом GSCOMP и GETSTARS;

            - естественно, что  изменения в любом из файлов программы тре-
              буют его повторного ассемблирования;

            - наконец, если хотя бы один из файлов был повторно  ассембли-
              рован, то необходима повторная компоновка.

              Для создания файла GETSTARS.EXE надо создать командный файл,
         содержащий приведенные выше команды.  Утилита MAKE позволяет сде-
         лать все это гораздо проще.




         TASM2 #5-5/Док               = 43 =

                               Параметры командной строки                      
         -----------------------------------------------------------------

              Приведем список  параметром командной строки.  Заметим,  что
         имеет значение регистр буквы параметра.  Например, параметр -d не
         является допустимой заменой параметра -D.

         -----------------------------------------------------------------
         Параметр               Функции
         -----------------------------------------------------------------
         -? или -h              Выводит справочную информацию.

         -a                     Приводит к автоматической проверке зависи-
                                мостей в объектных файлах.

         -B                     Выполняет построение всех  целевых файлов,
                                независимо от их даты.

         -Dидентификатор
                                Определяет идентификатор для строки,  сос-
                                тоящей из одного символа 1 (единица).

         -Dидентификатор=строка Определяет идентификатор с именем "иденти-
                                фикатор"  для  строки,  стоящей  справа от
                                символа =.  Строка   не  может  содержать
                                пробелов или символов табуляции.

         -i                     Не проверяется  (игнорируется)   состояние
                                завершения  (код  выхода)   при выполнении
                                всех программ.  Выполнение продолжается не
                                зависимо  от кода завершения.  Это эквива-
                                лентно помещению символа "-"  перед  всеми
                                командами  в формирующем файле (см. ниже).

         -Iкаталог              Включаемые файлы ищутся в указанном  ката-
                                логе (и в текущем каталоге).

         -K                     Сохраняются (не стираются) временные  фай-
                                лы, создаваемые утилитой MAKE. Все времен-
                                ные  файлы  имеют  вид  MAKE####.$$$,  где
                                #### принимает  значения  в  диапазоне  от
                                0000 до 9999.

         -n                     Выводит команды, но не выполняет  их.  Это
                                полезно использовать для отладки формирую-
                                щего файла.

         TASM2 #5-5/Док               = 44 =


         -s                     Команда не  выводится  перед  выполнением.
                                Обычно утилита MAKE выводит каждую  коман-
                                ду, когда приходит время выполнять ее.

         -S                     Выполняется свопинг утилиты MAKE из памяти
                                при  выполнении  команд.  Это  существенно
                                уменьшает потребность в памяти и позволяет
                                компилировать очень большие модули.

         -Uидентификатор        Разопределяет все  предыдущие  определения
                                идентификатора с указанным именем.

         -W                     Текущие не строковые параметры  становятся
                                используемыми по умолчанию (записываются в
                                файл MAKE.EXE. Используемые  по  умолчанию
                                параметры выводятся при задании параметров
                                -? или -h, плюс последующий символ.
         -----------------------------------------------------------------

                           Простое использование утилиты MAKE                  
         -----------------------------------------------------------------

              Давайте рассмотрим пример использования утилиты MAKE,  лежа-
         щий вне области программирования. Предположим, вы пишете книгу, и
         решили хранить  каждую  ее главу в отдельном файле.  (Предположим
         в данном примере также,  что это довольно короткая книга: она со-
         держит три главы в файлах CHAP1.MSS, CHAP2.MSS, CHAP3.MSS.) Чтобы
         получить текущий набросок книги, вы пропускаете каждую главу кни-
         ги через программу форматирования FORM.EXE, а затем вызываете ко-
         манду DOS COPY для объединения полученного текста в одном файле:

                          form.exe
              Chap1.MSS ===========> Chapt1.txt  \
                          form.exe                -------------\
              Chap2.MSS ===========> Chapt2.txt   команда COPY  > Book.TXT
                          form.exe                -------------/
              Chap3.MSS ===========> Chapt3.txt  /

              Как и программирование,  написание книги  требует много вни-
         мания. По  мере  продвижения  работы   над   книгой   вы   можете
         модифицировать содержимое  одного или более ее файлов,  но вам не
         хочется переключать внимание на то,  чтобы отмечать, какие именно
         файлы вы  изменили.  С другой стороны,  вам не хотелось бы забыть
         пропустить один или более измененных файлов  через  форматировщик

         TASM2 #5-5/Док               = 45 =

         перед тем, как вы скомбинируете их с другими файлами, ведь вы хо-
         тите получить полностью обновленный вариант книги.

              Один и не совсем изящный и требующий  много  времени  способ
         решить данную  проблему  состоит  в том,  чтобы переформатировать
         каждый файл книги. Для этого можно создать командный файл, содер-
         жащий следующие команды:

                 FORM CHAP1.MSS
                 FORM CHAP2.MSS
                 FORM CHAP3.MSS
                 COPY /A CHAP1.TXT+CHAP2.TXT+CHAP3.TXT BOOK.TXT

              При запуске данного командного файла всегда  будет  получена
         обновленная версия  вашей книги.  Предположим,  однако,  что ваша
         книга разрослась и стала содержать 15 глав.  Процесс форматирова-
         ния всей книги может оказаться слишком длительным.

              В ситуациях  такого  рода выход помогает найти утилита MAKE.
         Все, что вам потребуется сделать - это создать файл,  который на-
         зывается обычно MAKEFILE,  который сообщит утилите MAKE, от каких
         файлов зависит содержимое BOOK.TXT,  и как нужно  их  обработать.
         Данный файл будет содержать правила, поясняющие, как сформировать
         BOOK.TXT, когда некоторые из файлов,  от которых зависит содержи-
         мое книги, изменились.

              В данном примере в формирующем файле можно использовать сле-
         дующее правило:

              book.txt: chap1.txt chap2.txt chap3.txt
                   copy /a chap1.txt+chap2.txt+chap3.txt book.txt

              Что это означает?  В первой строке указывается, что BOOK.TXT
         зависит от форматированных текстов каждой из трех глав.  Если ка-
         кой-либо из файлов,  от которых зависит BOOK.TXT,  новее, чем сам
         файл BOOK.TXT,  то  утилита  MAKE  должна  переформировать   файл
         BOOK.TXT, выполнив команду COPY на следующей строке.

              Однако, одно  данное  правило мало о чем говорит.  Каждый из
         файлов глав зависит от файла документа .MSS.  Если какой-либо  из
         файлов CHAP?.TXT будет новее,  чем соответствующий файл .MSS,  то
         файл .MSS будет переформирован. Таким образом, в формирующий файл
         следует добавить еще несколько правил:

              chap1.txt: chap1.mss
                         form chap1.mss

         TASM2 #5-5/Док               = 46 =

              chap2.txt: chap2.mss
                         form chap2.mss
              chap3.txt: chap3
                         form chap3.mss

              Каждое из этих правил показывает,  как  нужно  форматировать
         каждую из  глав (если это необходимо) из исходного файла докумен-
         та.

              Утилита MAKE "понимает",  что она должна обновить файлы,  от
         которых зависит другой файл, перед тем, как обновить данный файл.
         Таким образом,  если вы измените CHAP3.MSS, утилита MAKE перефор-
         матирует Главу 3, и потом уже сформирует из файлов .TXT BOOK.TXT.

              Мы может несколько дополнить данный пример. При правила выг-
         лядят в основном одинаково. Фактически, за исключением цифры гла-
         вы (последний символ в имени каждого файла) они идентичны. Поэтому
         довольно легко забыть добавить  в формирующий файл новое правило,
         когда вы  начнете новую главу.  Чтобы решить эту задачу,  утилита
         MAKE позволяет вам использовать неявное правило,  которое показы-
         вает, как получить один тип файлов из другого (на основе расшире-
         ний файлов). В данном случае все три правила можно заменить одним
         неявным правилом:

              .mss.txt:
                         form $*.mss

              Данное правило говорит: "Если нужно сформировать для получе-
         ния текущих  изменений  файл из файла .MSS,  то это можно сделать
         так". (Вам придется изменить первое  правило,  определяющее,  как
         формировать BOOK.TXT.  После этого утилита MAKE будет знать,  как
         нужно объединять новые главы в выходной файл. В данном и последу-
         ющем правилах используется макрокоманда.  О макрокомандах мы расс-
         кажем позднее.)

              После того,  как вы создадите формирующий файл, вам потребу-
         ется только  для получения обновленного варианта книги в ответ на
         подсказку DOS дать одну команду: MAKE.




         TASM2 #5-5/Док               = 47 =

                              Создание формирующих файлов                      
         -----------------------------------------------------------------

              Формирующий файл содержит определения,  команды и директивы,
         используемые программой-утилитой MAKE для обновления вашей  прог-
         раммы. Можно создать столько формирующих файлов, сколько потребу-
         ется, и назвать их произвольными именами. Если при запуске утили-
         ты  MAKE  (с  необязательным  параметром  -f)  вы  не задаете имя
         формирующего файла,  то она будет искать файл с  используемым  по
         умолчанию именем MAKEFILE.

              Формирующий файл можно создать с помощью текстового редакто-
         ра,  работающего в кодах ASCII (такого, как, например, встроенный
         интерактивный редактор Турбо Си или Турбо Паскаля).  Все правила,
         определения и директивы заканчиваются символом  возврата каретки.
         Если строка является слишком длинной, то вы можете закончить ее в
         следующей строке, помещая знак продолжения - обратную косую черту
         (\) - в последней позиции продолжаемой строки.

              Пробелы и точки используются для отделения расположенных ря-
         дом идентификаторов (таких как зависимости) и чтобы выделять  ко-
         манды  внутри правил.  Приведем список конструкций,  допустимых в
         формирующем файле:

              - комментарии;
              - явные правила;
              - неявные правила;
              - макроопределения;
              - директивы (включение файла, условное выполнение, определе-
                ние ошибки, макроудаление).

              Таким образом, файл типа make (или формирующий файл) состоит
         из двух списков:  зависимостей и  команд.  Зависимости  указывают
         утилите MAKE,  какие файлы зависят от данного файла; команды ука-
         зывают MAKE, как создать данный файл из других.

              Если взять за основу первый из приведенных примеров,  то ваш
         формирующий файл в этом случае будет иметь следующий вид:

         getstars.exe: getstars.obj gscomp.obj gsparcs.obj starlib.obj
         tlink starlib gsparse gscomp getstars,getstars, lib\io lib\math

         getstars.obj: getstars.asm stardefs.inc starlib.inc gscomp.inc \
                           gsparse.inc
         tasm /t /ml /s getstars.asm


         TASM2 #5-5/Док               = 48 =

         gscomp.obj:  gscomp.asm stardefs.inc starlib.inc gscomp.inc
         tasm /t /ml /s gscomp.asm

         gsparse.obj: gsparse.asm stardefs.inc starlib.inc gsparse.inc
         tasm /t /ml /s gsparse.asm

         starlib.obj: starlib.asm
         tasm /t /ml /s starlib.asm

              Это выглядит несколько непонятным. Дадим пояснения:

              - Первая   строка   указывает   утилите   MAKE,   что   файл
                GETSTARS.EXE зависит от четырех объектных файлов.

              - Вторая  строка  указывает  MAKE,   как   построить   новый
                файл GETSTARS. EXE.

              - Следующие строки (пустые  строки  игнорируются)  указывают
                утилите  MAKE,  что файл GETSTARS.OBJ зависит от пяти фай-
                лов.  При внесении  изменений  в  один  из  файлов  модуль
                getstars.asm  должен быть перетранслирован при помощи при-
                веденной во второй строке команды.



         TASM2 #5-5/Док               = 49 =

                                                                               
         Компоненты формирующих файлов
         -----------------------------------------------------------------

              В формирующих файлах допустимы следующие конструкции:

              - комментарии;

              - определенные правила;

              - подразумеваемые правила;

              - макроопределения;

              - директивы включения файлов,  условного выполнения, распоз-
                навания ошибок и отмены макрокоманд.




         TASM2 #5-5/Док               = 50 =

                                      Комментарии                              
         -----------------------------------------------------------------

              Комментарии начинаются с символа (#). Содержимое строки пос-
         ле этого символы игнорируется утилитой  MAKE.  Комментарии  могут
         быть размещены где угодно,  но не могут начинаться с определенных
         колонок. Остаток строки,  следующий за знаком # игнорируется обс-
         луживающей программой MAKE.  Комментарии могут помещаться в любом
         месте, и не обязательно должны начинаться в какой-то определенной
         позиции.

              Символ обратной косой черты (\) не продолжает комментарий на
         следующую строку. Вместо него вы должны воспользоваться на каждой
         строке знаком #.  В действительности вы не можете воспользоваться
         в качестве знака продолжения обратной косой чертой в строке,  ко-
         торая имеет комментарий. Это происходит из-за того, что, если об-
         ратная косая черта предшествует знаку #,  то он более не является
         последним знаком в данной строке. Если же он следует за знаком #,
         то он сам является частью комментария. Приведем некоторые примеры
         комментариев в формирующем файле:


           # формирующий файл для GETSTARS.EXE
           getstars.exe:getstars.obj gscomp.obj gsparse.obj starlib.obj
           # нельзя помещать комментарий в конец следующей строки
           tlink starlib gsparse gscomp getstars,getstars,\
                  lib\io lib\math
           # правильный комментарий
           # нельзя помещать комментарий между следующими двумя строками
           getstars.obj: getstars.asm stardefs.inc starlib.inc gscomp.inc
                           gsparse.inc
           tasm /t /ml /s getstars # можно поместить комментарий здесь




         TASM2 #5-5/Док               = 51 =

                                    Командные списки                           
         -----------------------------------------------------------------

              Явные и неявные правила (см.  далее) используют  списки  ко-
         манд. Давайте обсудим эти команды и их возможности.

              Команды в  командном  списке должны начинаться с абзаца,  то
         есть им должен предшествовать по крайней мере один  знак пробела,
         и они должны иметь следующий вид:

                   [ префикс ... ] тело_команды

              Каждая командная  строка  в  списке команд состоит из списка
         (неoбязательного) префиксов, за которым должно следовать одно те-
         ло команды.

                                     Префиксы

              Префиксы, которые можно использовать в команде, изменяют об-
         работку обслуживающей программой МAКЕ этих команд.  Префиксом яв-
         ляется  или  символ  @ или дефис (-),  непосредственно за которым
         следует число.

         -----------------------------------------------------------------
         Префикс           Что он делает
         -----------------------------------------------------------------
              @         Не позволяет обслуживающей программе МAКЕ выводить
                        команду  на  экран перед ее выполнением.  Вывод не
                        осуществляется,  даже если в командной строке ути-
                        литы МAКЕ не был задан необязательный параметр -s.
                        Этот префикс относится только к той команде, в ко-
                        торой он указывается.

           - число      Влияет на то, как обслуживающая программа МAКЕ об-
                        рабатывает коды завершения.  Если число указывает-
                        ся,  то обслуживающая программа МAКЕ прерывает об-
                        работку в том случае только,  если  значение  кода
                        завершения превышает заданное число. В приведенном
                        ниже примере обслуживающая программа  МАКЕ прервет
                        выполнение только в том случае,  если код заверше-
                        ния превысит по значению число 4:

                                    -4 myprog sample.x

                        Если "-число префикс" не задается,  то обслуживаю-
                        щая программа МАКЕ проверяет  код  завершения  для

         TASM2 #5-5/Док               = 52 =

                        данной команды.  Если этот код является ненулевым,
                        то обслуживающая программа  остановится  и  удалит
                        текущий целевой файл.

              -         При наличии дефиса без номера обслуживающая  прог-
                        рамма MAKE не будет проверять код завершения.  Не-
                        зависимо от кода завершения обслуживающая програм-
                        ма МAКЕ будет продолжать работу.
         -----------------------------------------------------------------
                                                   Тело команды                

              Тело команды трактуется точно также,  как если бы она указы-
         валась в качестве строки в файле COMMAND.COM,  за исключением то-
         го,  что  переадресация  ввода-вывода и программные каналы не ис-
         пользуются.

              Кроме операций изменения направления ввода и вывода >,  <, и
         >>, утилита  MAKE  использует  операции << и &&.  Данные операции
         создают файл,  позволяющий оперативно вводить  команду.  Операция
         << создает временный файл и переопределяет стандартный ввод таким
         образом, что он поступает из созданного файла.  Если у  вас  есть
         программа, которая  воспринимает  ввод со стандартного устройства
         ввода, команда:

              myprog <<!
              это проверка
              !

         создает временный файл,  содержащий строку "это проверка /n", пе-
         реопределяя ввод для myprog. Восклицательный знак в данном приме-
         ре является ограничителем.  Вы можете в качестве  ограничителя  в
         файле использовать любой символ,  кроме # и \. Первая строка, со-
         держащая в качестве первого символа ограничитель, завершает файл.
         Следующая за  ограничителем  (в данном случае это восклицательный
         знак) часть строки рассматривается, как часть предыдущей команды.

              Операция && аналогична операции <<.  Она  создает  временный
         файл. Но вместо использования стандартного ввода в команде,  опе-
         рация && замещается именем временного файла.  В следующем примере
         создается "файл подсказок" для утилиты TLINK:

              MYPROG.EXE : $((MYOBJS)
                    tlink /e  &&!
              COS $(MYOBJS)
              $*

         TASM2 #5-5/Док               = 53 =

              $*
              $(MYLIBS) EMULLIB.LIB MATHLIB.LIB OB.LIB

              Заметим, что макрокоманды (показанные символами $)  расширя-
         ются при создании файла.  $* заменяется именем формируемого файла
         (без расширения),  в $(MYOBJS) и $(MYLIBS) заменяются  значениями
         макрокоманд MYOBJ и MYLIB.  Таким образом, TLINK может рассматри-
         вать файл, который выглядит следующим образом:

               COS a.obj b.obj c.obj d.obj
               MYPROG
               MYPROG
               w.lib x.lib y.lib z.lib EMU.LIB MATHS.LIB CS.LIB

              Все временные файлы удаляются (если только в командной стро-
         ке вы не используете параметр -K).  Если окажется, что файл рабо-
         тает направильно, параметр -K можно использовать для отладки.
                                                 Списки программ               

              Утилита MAKE   позволяет   работать   со  списком  программ.
         Предположим, например,  что утилита MAKE должна передать для  об-
         работки  несколько  файлов  Турбо Ассемблеру.  Утилита MAKE может
         запустить Турбо Ассемблер для каждого файла,  но более эффективно
         было бы  вызвать  Турбо Ассемблер,  указав в его командной строке
         список всех  ассемблируемых файлов.  При этом не нужно будет каж-
         дый раз перезагружать TASM.

              Средства утилиты MAKE позволяют вам накапливать имена файлов
         для обработки их в команде, комбинируя их в список, и вызывая ко-
         манду один раз для всего списка.

              Чтобы MAKE формировала список,  вам нужно использовать в ко-
         мандной строке фигурные скобки:

                  команда ком_строка...{ эл_списка } ...остаток_команды

              При таком синтаксисе команды выполнение команды откладывает-
         ся, пока   утилита  MAKE  не  определит,  что  ей  нужно  вызвать
         следующую команду.  Если следующая команда идентична,  то две ко-
         манды комбинируются  путем присоединения части команды,  располо-
         женной вне скобок.

              Приведем пример, показывающий, как данное средство работает.
         Предположим, утилита  MAKE последовательно вызывает следующие три
         команды:

         TASM2 #5-5/Док               = 54 =


                  tasm {file1.asm }
                  tasm {file2.asm }
                  tasm {file3.asm }

              Вместо того, чтобы три раза вызывать Турбо Ассемблер, утили-
         та MAKE использует одну команду:

                  tasm file1.asm file1.asm file1.asm

              Заметим, что  пробелы в конце каждого имени файла в фигурных
         скобках играют существенную  роль.  Это  разделитель.  Содержимое
         скобок просто объединяется в том виде, как есть.

              Приведем пример,  в  котором  используется  неявное правило.
         Предположим, ваш формирующий файл содержит неявное правило компи-
         ляции программ на Ассемблере в файлы .OBJ:

              .asm.obj:
                        TASM - c { $< }

              Когда утилита MAKE использует для каждого  файла  Ассемблера
         неявное правило,  она  расширяет  макрокоманду  $< в реальное имя
         файла и добавляет это имя к списку файлов для компиляции.  (Обра-
         тите опять внимание на пробелы в скобках, которые служат раздели-
         телями.) Список растет,  пока утилита MAKE не обнаружит,  что  ей
         нужно запускать другую программу,  отличную от TASM, либо пока не
         будет исчерпано пространство для командной строки.  Если это про-
         исходит, утилита MAKE помещает в командную строку столько данных,
         сколько может,  а остаток помещает в следующую командную  строку.
         Когда список будет сформирован, утилита MAKE вызывает TASM (с па-
         раметром -c для обработки сразу всего списка.
                                            Выполнение команд DOS              

              Обслуживающая программа МAКЕ выполняет  следующие  "встроен-
         ные"   команды   DOS,  вызывая  для  их  выполнения  копию  файла
         COMMAND.COM:

               break      cd       chdir      cls      copy    ccty
               md         mkdir    path       prompt   rem     date
               rename     set      time       type     ver     del
               verify     vol      dir        echo     erase   rd
               rmdir

              Обслуживающая программа МAКЕ осуществляет поиск имени какой-

         TASM2 #5-5/Док               = 55 =

         либо другой команды с помощью алгоритма поиска ДОС:

              - Сначала  исследуется  текущий каталог,  за которым следует
                каждый каталог указанного маршрута.

              - В каждом каталоге ищется сначала файл с расширением
                .СОМ,  затем - файл с расширением .ВАТ, и, наконец, с расши-
                рением .ЕХЕ.

              - Если найден файл .ВАТ, то вызывается копия COMMAND.COM для
                выполнения командного файла.

              Очевидно, что  если расширение в командной строке указывает-
         ся,  то обслуживающая программа МАКЕ  осуществляет  поиск  только
         для этого расширения.

              Приведем примеры. Эта команда заставит COMMAND.COM выполнить
         команду изменения каталога:

                 cd c:\include

              Эта команда будет найдена для использования алгоритма полно-
         го поиска:

                tpc myprog.pas /$B+,R+,I+

              Эта команда  будет найдена для использования только расшире-
         ния .СОМ:

              myprog.com geo.zyz

              Следующая команда будет выполнена с помощью  указанного
         имени явного файла:

              c:\myprogs\fil.exe -r

              Утилита MAKE  использует полный алгоритм поиска для нахожде-
         ния файлов для выполнения следующей команды:

              tlink lib\cos z, y,z,z,lib\cs

              MAKE выполняет поиск следующего файла, используя только рас-
         ширения .COM:

              myprog.com geo.xyz


         TASM2 #5-5/Док               = 56 =

              MAKE ищет  следующий  файл,  используя  указанное  явное имя
         файла:

              c:\myprogs\fil.exe -r




         TASM2 #5-5/Док               = 57 =

                                      Явные правила                            
         -----------------------------------------------------------------

              Правило в  последнем примере представляет собой явное (опре-
         деленное) правило, то есть правило, в котором имя файла определе-
         но полностью. Это правило имеет следующий синтаксис:

         целевой_файл [целевой_файл ...]: [исходный_файл исходный_файл...]
                      [команда]
                      [команда]
                      ...

              Здесь целевой_файл - имя файла, который должен быть изменен,
         исходный_файл  - это имя файла, от которого зависит целевой файл,
         а команда - любая команда MS-DOS (включая вызов  командного файла
         и исполнение файлов .COM и .EXE).

              Смысл, который  несет  с собой использование явного правила,
         заключается в том,  что заключительные команды создадут или изме-
         нят файл "целевой_файл", обычно используя файлы "исходный_ файл".
         Когда обслуживающая программа MAKE  обнаруживает  явное  правило,
         она сначала выясняет, не являются ли какие-либо файлы сами файла-
         ми "целевой_файл" где-нибудь в другом месте в  формирующем файле.
         Если да, то такие правила вычисляются первыми.

              Когда все файлы "исходный_файл" созданы или изменены в соот-
         ветствии с другими явными (или неявными) правилами, обслуживающая
         программа MAKE проверяет, существует ли файл "целевой_файл". Если
         нет, то каждая команда вызывается в заданном порядке. Если "целе-
         вой_файл" не существует,  то время и дата его последней модифика-
         ции сравниваются с временем и  датой  модификации  каждого  файла
         "исходный_файл". Если какой-либо из файлов "исх_файл" был изменен
         позднее, чем файл "целевой_файл", то выполняется список команд.

              Данное имя файла может появиться с левой стороны явного пра-
         вила один раз в данном выполнении обслуживающей программы MAKE.

              Каждая командная  строка в явном правиле начинается с пробе-
         ла. Обслуживающая программа МAКЕ рассматривает все строки, следу-
         ющие  после явного правила и до следующей строки,  начинающейся в
         колонке 1 (без предшествующего пробела) или до конца файла, в ка-
         честве части списка команд этого правила. Строки пробелов игнори-
         руются.  Явное правило без командных  строк,  следующих  за  ним,
         рассматривается  несколько иначе,  чем явное правило с командными
         строками.


         TASM2 #5-5/Док               = 58 =

              - Если явное правило существует для целевого файла с  коман-
         дами,  то единственными файлами,  от которых зависит этот целевой
         файл, являются файлы, перечисленные в этом явном правиле.

              - Если явное правило не имеет команд, то целевые файлы зави-
         сят от файлов, указанных в явном правиле, а также они могут зави-
         сеть от любого файла, удовлетворяющего неявному правилу для целе-
         вых файлов.

              - Ниже показан формирующий файл с примерами явных правил:

              myutil.obj:myutil.asm
               masm myutil.asm.myutil.obj;

              myapp.exe:  myapp.pas myglobal.tpu myutils.tpu
               tpc myapp /Tc:\tp4\bin

              myglobal.tpu: myglobal.pas
               tpc myglobal /Tc:\tp4\bin

              myutils.tpu: myutlis.pas myglobal.tpu myutil.obj
               tpc myutils /Tc:\tp4\bin

              - Первое явное правило указывает,  что файл MYUTIL.OBJ зави-
         сит от файла MYUTIL.ASM,  а файл MYUTIL.OBJ создан при выполнению
         заданной команды MASM.  (Параметр /Т и имя маршрута в этих приме-
         рах будут объяснены несколько позже).

              - Второе правило утверждает,  что файл MYAPP.EXE зависит  от
         MYAPP.PAS,  MYGLOBAL.TPU и MYUTILS.TPU и что он создан данной ко-
         мандой TPC.

              - Третье правило указывает, что файл MYGLOBAL.TPU зависит от
         файла MYGLOBAL.PAS и создан заданной командой ТРС.

              - Последнее  правило указывает,  что файл MYUTIL.TPU зависит
         от файлов MYUTILS.PAS,  MYGLOBAL.TPU и MYUTIL.OBJ и что он создан
         заданной командой ТРС.

              - Если   вы  реорганизуете  правило  так,  что  правило  для
         MYAPP.EXE становится первым,  а за ним следует остальные, то обс-
         луживающая  программа МAКЕ перекомпилирует (или переассемблирует)
         только те файлы,  которые она должна перекомпилировать (или пере-
         ассемблировать) для того, чтобы правильно осуществлять коррекцию.
         Это происходит из-за того,  что обслуживающая программа МAКЕ  без
         целевого  файла  в  командной строке попытается выполнить сначала

         TASM2 #5-5/Док               = 59 =

         первое явное правило, которое она найдет в формирующем файле.

              - В действительности вы обычно должны опустить два последних
         явных  правила и просто добавить директиву /М к команде под явным
         правилом для файла MYAPP.EXE.  Вам однако необходимо будет  доба-
         вить все зависимости файлов MYGLOBAL.TPU и MYUTILS.TPU к исходно-
         му файлу для MYAPP.EXE.

              В правилах такого рода определяются один или несколько целе-
         вых  файлов,  ни  одного или несколько исходных файлов и необяза-
         тельный список исполняемых команд. Имена целевых и исходных  фай-
         лов,  содержащиеся в определенных правилах, могут содержать явное
         указание дисковода и тот каталог,  где они находятся.  В правилах
         нельзя использовать трафаретные символы.

              Синтаксис правила  имеет очень важное значение. Имя целевого
         файла должно начинаться с первой позиции строки. Перед каждой ко-
         мандой должен указываться хотя бы один пробел,  либо символ табу-
         ляции. Как отмечалось выше, для продолжения строки может быть ис-
         пользован символ обратной косой черты (\). Наконец, исходные фай-
         лы и команды в правилах необязательны. Можно чтобы правило состо-
         яло только из имен целевых файлов,  список  которых  заканчивался
         символом двоеточия (:).

              Суть определенного правила состоит в том,  что команды, ука-
         занные в нем,  должны создавать или изменять целевой файл, обычно
         используя исходные файлы. Когда утилита MAKE встречает определен-
         ное правило, то она проверяет, является ли любой из исходных фай-
         лов  в  свою  очередь целевым файлом в этом же формирующем файле.
         Если это так, то данное правило рассматривается первым.

              Так как все исходные файлы были созданы или изменены на  ос-
         нове (подразумеваемых) определенных правил, утилита MAKE проверя-
         ет,  существует ли целевой файл. Если целевой файл не существует,
         то команды выполняются в приведенном порядке. Если он существует,
         то дата и время его создания сравниваются с датой и временем каж-
         дого исходного файла. Если в исходный файл изменения были внесены
         позже, то будет выполнен приведенный список команд.

              Данное имя файла может указываться  в  левой  части  правила
         только один раз при каждом выполнении утилиты MAKE.

              Каждая командная  строка начинается с пробелов. Утилита MAKE
         считает все строки,  следующие за явным правилом,  частью  списка
         команд для этого правила до первой строки,  начинающейся с первой
         позиции или до конца файла (пустые строки игнорируются).

         TASM2 #5-5/Док               = 60 =

                                                                               
                              Специальные соглашения

              Итак, явные правила  без  командных  списков  воспринимаются
         немного иначе, чем правила с командными списками.

             - если  явное  правило  содержит список команд,  то в правиле
               должны быть только те файлы,  от которых зависит данный це-
               левой файл;

             - если явное правило не содержит команд, то целевые файлы за-
               висят как от файлов,  приведенных в этом правиле,  так и от
               файлов, указанных в подразумеваемом правиле.
                                                       Примеры                 

             Приведем еще несколько примеров явных правил:

                 myprog.obj: myprog.asm
                  tasm /t myprog.asm

                 prog2.obj:prog2.asm include\stdio.inc
                  tasm /t /ml prog2.asm

                 prog.exe: myprog.asm prog2.asm include\stdio.inc
                  tasm /t  myprog.asm
                  tasm /t /ml prog2.asm
                  tlink myprog prog2, prog, lib\io

             - Первое  правило устанавливает,  что файл MYPROG.OBJ зависит
               от MYPROG.ASM,  и MYPROG.OBJ  создается  вызовом  программы
               TASM.

             - Аналогично, второе правило устанавливает, что PROG2.OBJ за-
               висит от PROG2.ASM и STDIO.INC (в поддиректории INCLUDE)  и
               создается командой TASM.

             - Последнее правило устанавливает,  что файл PROG.EXE зависит
               от MYPROG.ASM, PROG2.ASM, и STDIO.INC и если хотя бы в один
               из этих файлов внесены изменения,  то PROG2.EXE должен быть
               преобразован при помощи списка приведенных  в  правиле  ко-
               манд. Но при этом если изменения внесены в файл MYPROG.ASM,
               то придется повторно компилировать и файл PROG2.ASM.

             - Если вы добавите в качестве первого правила:


         TASM2 #5-5/Док               = 61 =

                prog.exe: myprog.obj prog2.obj
                 tlink myprog prog2, prog,,lib\io

         это позволит  избежать напрасных действий при изменении одного из
         исходных файлов.
                                  Автоматическая проверка зависимости          

              Турбо Ассемблер,  работая совместно с  утилитой  MAKE  фирмы
         Borland, обеспечивает проверку зависимости для включаемых файлов.
         TASM создает файлы .OBJ,  которые указывают утилите  MAKE,  какие
         включаемые файлы были использованы для их создания.  Для проверки
         этой информации и обеспечения обновления всех  файлов используйте
         параметр командной строки -s.

              Когда утилита MAKE выполняет автоматическую проверку зависи-
         мости, она считывает имена включаемых файлов,  время  и  даты  их
         создания из файла .OBJ.  Если какой-либо из включаемых файлов был
         модифицирован, то утилита MAKE  перекомпилирует  объектный  файл.
         Рассмотрим следующий формирующий файл:

              .asm.obj:
                  tasm -c $*

              Предположим теперь, что с помощью TASM компилируется следую-
         щий исходный файл с именем MYFILE.ASM:

              #include <stdio.inc>
              #include "dcl.inc"

              void myfile() { }

              Если вы с помощью вызовите утилиту MAKE с  помощью следующей
         командной строки:

              make -a myfile.obj

         то она проверяет время и дату создания файла MYFILE.ASM,  а также
         файлов STDIO.INC и DCL.INC.




         TASM2 #5-5/Док               = 62 =

                                    Неявные правила                            
         -----------------------------------------------------------------

              Неявные правила - это обобщение явных правил.  Ниже приведен
         пример, иллюстрирующий зависимости между двумя типами правил:

               starlib.obj: starlib.asm
               tasm /t /ml /s starlib.asm

              Это правило  является общим, так как оно построено по основ-
         ному принципу: файл .OBJ зависит от файла  .ASM с  таким же  име-
         нем и создается при запуске Турбо Ассемблера TASM.

              Переопределив явные  правила в неявные,  вы можете устранить
         определенные правила одинаковой формы.  Неявное правило  выглядит
         следующим образом:

                    .asm.obj:
                      tasm /t /ml /s $<

              Оно означает,  что  любой файл .OBJ зависит от файла с таким
         же именем, но расширением .ASM, и файл .OBJ создается командой:

                    tasm /t /ml /s $<

         где $< представляет имя файла с расширением .ASM.  (Это специаль-
         ная макрокоманда).

              Синтаксис неявного правила следующий:

              .расширение_исходного_файла.расширение_целевого_файла
                            [команда]
                            [команда]
                               ...

         где, как и ранее, команды необязательны и могут быть опущены.

              Параметр .расширение_исходного_файла (который  должен  начи-
         наться с первой позиции строки) представляет собой расширение ис-
         ходного файла; оно применяется к любому файлу, имеющему следующий
         формат:

              имя.расширение_исходного_файла

              Аналогично параметр .расширение_целевого_файла ссылается  на
         файл:

         TASM2 #5-5/Док               = 63 =


              имя.расширение_целевого_файла

         где имя - имя одинаковое для обоих файлов.  Иначе говоря, неявное
         правило заменяет все явные правила, имеющие следующий формат:

              имя.расширение_целевого_файла:имя.расширение_исходного_файла
                            [команда]
                            [команда]
                               ...
              для любого параметра <имя>.

              Неявные правила используются тогда,  когда отсутствуют явные
         правила для найденного целевого файла, либо если явное правило не
         содержит команд.

              Расширение файла  используется  для  определения того, какое
         неявное должно быть использовано.

              Например, предположим,  что у вас есть формирующий  файл  (с
         именем MAKEFILE), который содержит следующее правило:

                .asm.obj:
                 tasm /t /ml /s $<

              Если у вас есть программа на Ассемблере с  именем RATIO.ASM,
         и вы хотите компилировать ее в файл RATIO.OBJ, то нужно использо-
         вать команду:

                      make ratio.obj

              Утилита MAKE воспримет файл RATIO.OBJ,  как целевой. Так как
         нет явных правил для создания RATIO.OBJ,  MAKE  применит  неявное
         правило и сгенерирует команду:

                tasm /t /ml /s ratio.asm

              Неявные правила также используются тогда, когда в явном пра-
         виле отсутствует список команд.  Предположим, как упоминалось вы-
         ше, у вас есть следующее неявное правило в начале вашего формиру-
         ющего файла:

                .asm.obj:
                 tasm /t /ml /s $<

              Вы должны затем переписать последующие правила  таким  обра-

         TASM2 #5-5/Док               = 64 =

         зом:

             getstars.obj: stardefs.inc starlib.inc gscomp.inc gsparse.inc
             gscomp.obj: stardefs.inc starlib.inc
             gsparse.obj: stardefs.inc

              Так как вы не имеете определенной информации о том, как соз-
         давать эти объектные файлы,  то MAKE применит определенное  ранее
         неявное правило.

              Утилита MAKE использует первое неявное правило, которое отк-
         рывает файл с исходным расширением. Даже если команды в этом пра-
         виле неверны, другие неявные правила не проверяются.

              Все строки, следующие за правилом, воспринимаются как  часть
         списка  команд  для него до строки, начинающейся с первой позиции
         либо до конца файла. Пустые строки  игнорируются.  Синтаксис  для
         строки команд приведен ниже в этой главе.

              В отличие от случая с явными правилами,  обслуживающая прог-
         рамма МAКЕ при работе с неявным правилом не знает  полного  имени
         файла.  По этой причине обслуживающая программа МAКЕ поддерживает
         специальные макрокоманды,  которые позволяют включать имя данного
         файла,  построенное  в соответствии с эти правилом.  (Обсуждение,
         касающееся макроопределений,  более подробно приводится  далее  в
         этом приложении).

              Ниже приводится пример неявного правила:

              .pas.exe:
                tpc $<

              .pas.tpu:
                tpc $<

              В данном примере неявного правила целевыми  файлами являются
         файлы .ЕХЕ, а их исходными файлами являются файлы команд (синтак-
         сис командной строки приводится ниже). Кроме того, второе неявное
         правило создает файлы .TPU из файлов .PAS.




         TASM2 #5-5/Док               = 65 =

                                                                               
         Специальные соглашения
         -----------------------------------------------------------------

              В отличие от явных правил,  утилита MAKE  не  знает  полного
         имени файла  в неявном правиле.  В связи с этим введены специаль-
         ные макрокоманды, обеспечивающие включение имени файла.

                                                                               
         Примеры
         -----------------------------------------------------------------

              Ниже приведены примеры неявных правил:

              .c.obj
               tcc -c $<

              .asm.obj
               tasm $* /mx

              В первом примере - целевыми являются объектные файлы,  а ис-
         ходными -  файлы  на языке Си.  В этом примере приведена одна ко-
         мандная строка. Второй пример указывает утилите MAKE на необходи-
         мость ассемблирования данного файла с расширением .ASM при помощи
         команды TASM с параметром /mx.




         TASM2 #5-5/Док               = 66 =

                                                                               
         Примеры
         -----------------------------------------------------------------

              Эта команда будет выполнена командным процессором:

                     cd c:\include

              В этой команде поиск будет производится по полному алгоритму
         поиск:

                    tlink x,y,z,z.lib\io

              В следующей  команде поиск будет производится только по рас-
         ширению .COM:

                    myprog.com quy.xyz




         TASM2 #5-5/Док               = 67 =

                                    Макроопределения                           
         -----------------------------------------------------------------

              Определенные команды, имена файлов или параметры могут часто
         повторяться в формирующем файле. В таких случаях удобно использо-
         вать макроопределения.  Например, если вы пишете программу на Ас-
         семблере, использующую  среднюю  модель памяти,  то все программы
         используют параметр -mm,  задающий компиляцию со средней  моделью
         памяти. Предположим,  однако, что вы хотите перейти к большой мо-
         дели памяти.  Вы можете изменить все параметры -mm на  -ml.  Либо
         определить макрокоманду.

              Макроопределение - это имя, которое представляет собой неко-
         торую строку символов.  В макроопределении задается имя  и  текст
         расширения. Впоследствии, когда MAKE встречает имя макроопределе-
         ния (макрокоманду), данное имя заменяется на текст расширения.

              Предположим, в начале формирующего файла вы определили  сле-
         дующую макрокоманду:

              MODEL = m

              Это определяет  макрокоманду  MODEL,  которая теперь эквива-
         лентна строке  m.  С  помощью  данной  макрокоманды   мы   можете
         записывать каждую команду вызова TASM следующим образом:

              tasm -c -m$(MODEL) myprog.c

              При запуске   MAKE  каждая  макрокоманда  (в  данном  случае
         $MODEL) заменяется текстом ее расширения (здесь это m).  В  дейс-
         твительности будет выполнена команда:

              tasm -c mm myprog.c

              Теперь легко изменить модель памяти. Если вы измените первую
         строку на:

              MODEL = l

         то вы измените все макрокоманды таким образом,  что будет исполь-
         зоваться большая модель памяти. На самом деле модель памяти можно
         задавать при запуске MAKE с помощью параметра командной строки -D:

              make -DMODEL = l

              Это указывает утилите MAKE,  что MODEL  нужно  интерпретиро-

         TASM2 #5-5/Док               = 68 =

         вать, как макрокоманду, расширяющуюся в текст l.

              Приведем другой пример.  Предположим, вы определили макроко-
         манды:

               SRC=C:\ASM\
               OUT=OBJS\
               INC=C:\INC\

              Ваш формирующий файл будет выглядеть следующим образом:

            getstars.exe: $(OUT)getstars.obj $(OUT)gsparse \
                          $(OUT)gscomp.obj   $(OUT)starlib.obj
          tlink $(OUT)starlib $(OUT)gsparse $(OUT)gscomp $(OUT)getstars,\
                $(OUT)getstars,$(OUT)getstars, lib\io lib\math

           getstars.obj: $(SRC)getstars.asm $(INC)stardefs.inc \
                         $(INC)starlib.inc  $(INC)gscomp.inc   \
                         $(INC)gsparse.inc
           tasm /t /ml /s i$(INC) $(SRC)getstars.asm $(OUT)getstars.obj

         gscomp.obj: $(SRC)gscomp.asm $(INC)stardefs.inc $(INC)starlib.inc
           tasm /t /ml /s i$(INC) $(SRC)gcomp.asm $(OUT)gcomp.obj

         gsparse.obj: $(SRC)gparse.asm $(INC)stardefs.inc $(INC)starlib.inc
           tasm /t /ml /s i$(INC) $(SRC)gparse.asm $(OUT)gparse.obj

         starlib.obj: $(SRC)starlib.asm
           tasm /t /ml /s i$(INC) $(SRC)starlib.asm $(OUTstarlib.obj

              При запуске  утилиты MAKE макрокоманда $(SRC) будет заменена
         на C:\ASM\, макрос $(INC) на C:\INC\, а $(OUT) на \OBJS.

              Приведем еще один пример. Предположим, вы определили следую-
         щее макроопределение в начале формирующего файла:

              TURBO=c:tp5\bin

              Вы определили макроопределение TURBO, которое является экви-
         валентным строке c:tp5\bin. Теперь формирующий файл можно перепи-
         сать следующим образом:

              TURBO=c:tp5\bin
              myapp.exe: myapp.pas myglobal.tpu myutils.tpu
              tpc myapp /T${TURBO}
              myutils.tpu: myutils.pas myglobal.tpu myutil.obj

         TASM2 #5-5/Док               = 69 =

              tpc myutils /T${TURBO}
              myglobal.tpu myglobal.pas
              tpc myglobal /T${TURBO}
              myutil.obj: myutil.asm
              masm myutil.asm,myutil.obj;

              Везде, где указывается каталог TURBO,  используется макровы-
         зов $(TURBO). Когда вы выполняете обслуживающую программу МАКЕ, $
         (TURBO) замещается текстом его расширения,  c:\TP5.BIN. Результа-
         том будет являться тот же набор команд, то у вас был и ранее.

              Итак, что вы получили? Гибкость. Заменой первой строки на

              TURBO=c:\tp5\project

         вы заменили все команды, чтобы воспользоваться файлами конфигура-
         ции  или  библиотечными файлами в другом подкаталоге.  В действи-
         тельности,  если вы вышли из первой строки совсем,  то вы  можете
         указать с помощью необязательного параметра -D,  какой подкаталог
         нужно использовать при выполнении обслуживающей программы МAКЕ:

              make -DTURBO=c:tp5\project

              Указанное выше  предписывает  обслуживающей  программе  МAКЕ
         трактовать TURBO, как макроопределение с текстом расширения:

               c:tp4\project.

              Это дает существенную гибкость. Так, например, при смене ка-
         талога теперь надо изменить лишь текст макрокоманды.




         TASM2 #5-5/Док               = 70 =

                                                                               
         Определение макрокоманд
         -----------------------------------------------------------------

              Все макроопределения должны иметь вид:

              Имя_макро=Текст_расширения

              Имя_макро - это имя макрокоманды - строка букв и цифр,  сос-
         тоящая из букв и цифр, и не содержащая пробелов внутри имени.

              Текст_расширения -  любая  произвольная  строка,  содержащая
         буквы, цифры, пробелы, знаки пунктуации и завершающаяся  символом
         перевода строки.

              Переопределить макрокоманду можно либо в тексте формирующего
         файла, либо используя параметр -D в командной строке вызова.

              В именах  макроопределений прописные и строчные буквы разли-
         чаются. То есть имена макроопределений turbo, Turbo и TURBO расс-
         матриваются как имена различные.




         TASM2 #5-5/Док               = 71 =

                                                                               
         Использование макрокоманд
         -----------------------------------------------------------------

              Макрокоманда включается в формирующий файл в формате:

               $(имя_макрокоманды)

              Скобки всегда должны присутствовать,  даже если имя макроко-
         манды состоит из одного символа.  Исключение составляют специаль-
         ные макрокоманды, рассматриваемые ниже.

              Если MAKE встречает в  тексте  неопределенную  макрокоманду,
         она замещается на пустую строку (NULL).




         TASM2 #5-5/Док               = 72 =

                                     Особые случаи                             
         -----------------------------------------------------------------

         Вложенные макрокоманды:

              Макрокоманды не могут включаться в левую часть  макроопреде-
              ления, т.е. в (имя_макрокоманды). Они могут быть использова-
              ны в правой части.  Когда осуществляется макрогенерация, все
              макросы, включенные в текст расширения, также подставляются.

         Макрокоманды в правилах:

              В строках правил макрогенерация осуществляется тотчас же.

         Макрокоманды в директивах:

              В директивах  !if  и !elif макрогенерация осуществляется не-
              медленно. Если макрокоманда,  указанная в директиве, неопре-
              делена, она рассматривается как 0 (FALSE).

         Макрокоманды в командах:

              Макрогенерация в  командах производится во время их выполне-
              ния.




         TASM2 #5-5/Док               = 73 =

                             Предопределенные макрокоманды                     
         -----------------------------------------------------------------

              Утилита MAKE  использует  некоторые  специальные  встроенные
         макрокоманды: $d,  $ *, $<, $: , $. и $&. Первая из них определе-
         на, как тестовая макрокоманда (проверяет,  определено ли имя мак-
         рокоманды) и используется в условных директивах !if и !elif.  Ос-
         тальные  макрокоманды  (макрокоманды  имен файлов) используется в
         явных и неявных правилах. Кроме того, строки SET, устанавливающие
         текущее  окружение,  автоматически  загружаются как макрокоманды.
         Наконец,  макроопределение __MAKE__ определено,  как шестнадцати-
         ричная версия (Ox0300), а __MSDOS__ определено, как 1.

         -----------------------------------------------------------------
         Макрокоманда                       Что она делает
         -----------------------------------------------------------------
              $d           Определена, как тестовая макрокоманда.
              $*           Базовое имя файла с маршрутом.
              $<           Макрокоманда полного имя файла с маршрутом.
              $:           Макрокоманда маршрута.
              $.           Макрокоманда полного имени файла (без
                           маршрута).
              $&           Макрокоманда имени базового файла (без
                           маршрута).
         ------------------------------------------------------------------

                           $d - тестовая макрокоманда

              Тестовая макрокоманда заменяется на 1,  если определено  имя
         макрокоманды,  и на 0, в противном случае. Содержимое текста рас-
         ширения макрокоманд безразлично. Использование данной макрокоман-
         ды допускается только в директивах !if и !elif.

              Например, предположим  вы  хотите модифицировать формирующий
         файл,  так чтобы он использовал среднюю модель памяти. Добавьте в
         начало формирующего файла следующее:

                  !if !$d(MODEL)    # Если MODEL неопределено
                  MODEL=m           # Устанавливаем его в m (MEDIUM)
                  !endif

              Если вы затем вызовите утилиту MAKE командой:

                 make -DMODEL=l

         то MODEL будет определено, как l. Если же, однако, вы просто выз-

         TASM2 #5-5/Док               = 74 =

         овите утилиту MAKE по имени:

                 make

         то MODEL будет определено,  как "m" (как бы используемая по умол-
         чанию модель  памяти).

              Приведем еще один пример.  Предположим,  что вы хотите изме-
         нить  свой формирующий файл так,  чтобы он использовал конкретный
         каталог Турбо Паскаля. Вы можете указать его в начале своего фор-
         мирующего файла:

              ! if !$d(TURBO)        # Если TURBO не определяется,
              TURBO=c:\tp5\bin       # определите его как C:\TP5\BIN
              !endif

              Если вы вызвали обслуживающую программу МAКЕ командной стро-
         кой:

              make -DTURBO=c:\tp5\project

         то TURBO определяется как c:\tp5\project.  Если вы вызвали обслу-
         живающую программу МAКЕ просто ее собственным именем:

              make

         то TURBO определяется как c:\tp5\bin (подкаталог, рассматриваемый
         по умолчанию).

                             Макрокоманды имен файлов

              Эти макрокоманды действуют одинаково, разница состоит в раз-
         личном образовании имени полного маршрута файла.

                     $* - макроопределение основного имени файла

              Макрокоманда $* заменяется на имя файла, который должен быть
         построен, без  расширения  (основное или базовое имя файла).  Эту
         макрокоманду можно использовать в явных и неявных правилах.  Нап-
         ример:

               Имя файла: A:\P\TESTFILE.ASM

              $* расширяется до: A:\P\TESTFILE

              Например, вы можете модифицировать  явное  правило  в  вашем

         TASM2 #5-5/Док               = 75 =

         формирующем файле следующим образом:

            getstars.exe: getstars.obj gscomp.obj gsparse.obj starlib.obj
             tlink starlib gsparse gscomp $*,$*,$*,lib\math lib\io

              Либо явное правило вида:

              prog.exe: myprog.obj prog2.obj
                   tlink lib\cos myprog prog2, prog, , lib\cs

         изменить так, чтобы оно приняло вид:

              prog.exe: myprog.obj prog2.obj
                    tlink lib\cos myoprog prog2, $*, ,lib\cs

              При выполнении команды данного правила макрокоманда $* заме-
         няется именем целевого файла (без расширения) prog.  Для  неявных
         правил данная макрокоманда может оказаться очень полезной.

              Например, неявное правило для TASM может выглядеть так:

              .asm.obj:
                    tasm -c $*

                     $< - макроопределение полного имени файла

              Макрокоманда $< заменяется на полное имя файла, который  дол-
         жен быть построен.  Эта макрокоманда также используется для явных
         и неявных правил.  В явных правилах она  расширяется  до  полного
         имени целевого файла (включая его расширение), например:

               Имя файла: A:\P\TESTFILE.ASM

               $< расширяется до: A:\P\TESTFILE.ASM

               Например, правило:

                   starlib.obj :starlib.asm
                    copy $< \oldobjs
                    tasm /t $*

         будет копировать файл startlib.obj в каталог \oldobj (перед  ком-
         пиляцией startlib.asm).

              В неявных правилах макрокоманда $< заменяет имя файла  и его
         расширение. Например:

         TASM2 #5-5/Док               = 76 =


               .asm .obj:
                 tasm /t $* .asm

         может быть записано таким образом:

               .asm.obj :
                 tasm /t $<

         поскольку расширением целевого файла должно быть .asm.

                       $: - макроопределение имени маршрута

              Данная макрокоманда заменяется на имя маршрута (без  имени
         файла), например:

               Имя файла: A:\P\TESTFILE.ASM

               $: расширяется до: A:\P\

                  $. - макроопределение имени файла и расширения

                Имя файла: A:\P\TESTFILE.ASM

                $. расширяется до: TESTFILE.ASM

                     $& - макроопределение только имени файла

              Данная макрокоманда расширяется только до  имени  файла  без
         маршрута или расширения, например:

               Имя файла: A:\P\TESTFILE.ASM

               $& расширяется до: TESTFILE




         TASM2 #5-5/Док               = 77 =

                                       Директивы                               
         -----------------------------------------------------------------

              Утилита MAKE Турбо Ассемблера,  в отличие от  других  версий
         MAKE, допускает использование директив,  аналогичных тем, которые
         используются в языке Си,  Ассемблере и Турбо Паскале, позволяющих
         включать  другие формирующие файлы,  применять правила и условные
         команды,  печатать сообщения об ошибках и разопределять  макроко-
         манды.

              Директивы начинаются с символа (!), который должен быть пер-
         вым символом строки. Другие директивы начинаются с точки.

              Приведем полный перечень директив утилиты MAKE:

         -----------------------------------------------------------------
         .AUTODEPEND         Включает автоматическую проверку зависимости.
         !ELIF               Условное выполнение.
         !ELSE               Условное выполнение.
         !ENDIF              Условное выполнение.
         !ERROR              Приводит к тому, что утилита MAKE останавли-
                             вает работы и выводит сообщение об ошибке.
         !IF                 Условное выполнение.
         .IGNORE             Сообщает  MAKE,  что  значение  макрокоманды
                             нужно игнорировать.
         !INCLUDE            Определяет  файл,  включаемый  в  формирующий
                             файл.
         .NOAUTODEPEND       Отменяет автоматическую проверку зависимости.
         .NOIGNORE           Выключает .IGNORE.
         .NOSILENT           MAKE будет выводить команды перед  их  выпол-
                             нением
         .NOSWAP             Не будет выполняться  свопинг утилиты MAKE из
                             памяти.
         .PATH.EXT           Сообщает MAKE маршрут для поиска файлов с рас-
                             ширением .EXT.
         .SILENT             Сообщает MAKE, что не нужно  выводить  команды
                             перед их выполнением.
         .SWAP               Будет выполняться свопинг MAKE в память  и  из
                             памяти.
         !UNDEF              Отменяет определение указанной макрокоманды.
         -------------------------------------------------------------------




         TASM2 #5-5/Док               = 78 =

                                  Директивы с точками                          
         -----------------------------------------------------------------

              Каждой из следующих директив соответствует параметр  команд-
         ной строки, однако директива имеет более высокий приоритет (отме-
         няет соответствующий параметр).  Например, если вы вызываете ути-
         литу MAKE следующей командой:

                 make -a

         а в  формирующем  файле  содержится  директива .NOAUTODEPEND,  то
         автоматическая проверка зависимости будет выключена.

              Директивы .AUTODEPEND или .NOAUTODEPEND включают или  выклю-
         чают автоматическую проверку зависимости. Они соответствуют пара-
         метру командной строки -a.

              Директивы .IGNORE и .NOIGNORE указывают MAKE,  что нужно иг-
         норировать значение,   возвращаемое   командой.   Это  аналогично
         указанию префикса -. Они соответствуют параметру командной строки
         -i.

              Директивы .SILENT  и .NOSILENT сообщают утилите MAKE,  нужно
         или нет выводить на экран команды перед их выполнением. Они соот-
         ветствуют параметру командной строки -s.

              Директивы .SWAP  и .NOSWAP сообщают утилите MAKE,  что нужно
         выполнять свопинг из памяти.  Им соответствует параметр командной
         строки -S.

                            Директива .PATH.расширение

              Данная директива,  помещенная в формирующий файл,  указывает
         утилите MAKE,  где нужно искать файлы  с  указанным  расширением.
         Например, если в формирующем файле содержится:

              .PATH.asm = C:\TASMCODE

              .asm.obj:
                   tasm $*

              tmp.exe: tmp.obj
                   tasm tmp.onj

              Утилита MAKE  будет искать файл TMP.ASM (подразумеваемый ис-
         ходный файл для TMP.OBJ) в каталоге C:\TASMCODE,  а не в  текущем

         TASM2 #5-5/Док               = 79 =

         каталоге.

              .PATH - это также макрокоманда, которая имеет значение марш-
         рута. Приведем пример использования макрокоманды  .PATH. Исходные
         файлы содержатся в одном каталоге,  объектные файлы - в другом, а
         все файлы .EXE - в текущем каталоге.

              .PATH.asm = C:\TASMCODE
              .PATH.obj = C:\OBJS

              .asm.obj = C:\OBJS

              .asm.obj:
                 tasm -o$(.PATH.obj)\$& $<

              .obj.exe:
                 tasm -e$&.exe $<

              tmp.exe: tmp.obj




         TASM2 #5-5/Док               = 80 =

                               Директивы включения файлов                      
         -----------------------------------------------------------------

              Директива включения  файлов  определяет  имя  файла, который
         должен быть  включен в формирующий файл для интерпретации в точке
         появления этой директивы. Она имеет следующий вид:

                 !include "имя_файла"

              Директивы могут иметь произвольную вложенность. При  попытке
         включить файл, уже включенный на некотором внешнем уровне вложен-
         ности, директива внутреннего  уровня  будет  игнорироваться,  как
         ошибочная.

              Как же использовать эту директиву? Предположим,  вы  создали
         файл MODEL.MAC, содержащий следующую макрокоманду:

               !if !$d(MODEL)
               MODEL=medium
               !endif

              Для того,чтобы  использовать  эту макрокоманду в формирующем
         файле можно применить директиву !include:

               !include "MODEL.MAC".

              Когда MAKE встречает директиву !include,  утилита  открывает
         указанный файл и считывает его в выполняющийся формирующий файл.




         TASM2 #5-5/Док               = 81 =

                                   Условные директивы                          
         -----------------------------------------------------------------

              Условные директивы (!if, !else, !elif, !endif) предоставляют
         программисту большую гибкость при  создании  формирующих  файлов.
         Правила и макрокоманды можно сделать условными,  благодаря чему с
         помощью макроопределения в командной строке (параметр  -D)  можно
         разрешить или запретить использование части формирующего файла.

              Формат директив аналогичен  формату  директив  препроцессора
         Ассемблера, Си или Турбо Паскаля:

                  !if выражение
                          [строки]
                  !endif

                  !if выражение
                          [строки]
                  !else
                          [строки]
                  !endif

                  !if выражение
                          [строки]
                  !elif
                          [строки]
                  !endif

              Примечание: [строки] могут быть следующие:

               - макроопределения;
               - явное правило;
               - подразумеваемое правило;
               - директива включения файла;
               - группа if;
               - директива вывода сообщения об ошибке;
               - директива разопределения.

              Условные директивы  составляют группу, если имеется по край-
         ней мере одна директива  !if,  открывающая  группу,  и  директива
         !endif, закрывающая ее.

             -  Одна директива !else также может присутствовать в группе.

             -  Директивы !elif могут находиться между !if и !else.


         TASM2 #5-5/Док               = 82 =

             -  Правила, макрокоманды  и другие директивы могут находиться
                между любым количеством условных директив.

             - Между  различными  условными  директивами может содержаться
               любое число других директив,  правил или макрокоманд. Заме-
               тим,  что полные правила с их макрокомандами не должны раз-
               биваться условными директивами.

             - Условные  директивы  могут быть вложенными (на произвольную
               глубину).

              Каждая директива !if внутри файла должна иметь парную дирек-
         тиву !endif (в том же исходной файле).  Таким образом,  следующий
         включаемый файл недопустим,  независимо от того,  в каком правиле
         он  включается,  так как  в  нем  нет  соответствующей  директивы
         !endif:

              !if $(FILE_COUNT) > 5
                 некоторые правила
              !else
                 другие правила
              <конец правила>

              Все правила,  команды или директивы в  рамках  одного  файла
         должны быть полными.




         TASM2 #5-5/Док               = 83 =

                      Выражения, допустимые в условных директивах              
         -----------------------------------------------------------------

              Выражения, разрешенные  в условных директивах, имеют синтак-
         сис, аналогичный  используемому  в  языке  Ассемблера.  Выражение
         рассматривается, как простое 32-разрядное целое  выражение.

              Числа могут  задаваться  как  десятичные,  восьмеричные  или
         шестнадцатиричные константы. Например:

               4536   # десятичная константа
               0677   # восьмеричная константа
               0x23aF # шестнадцатиричная константа

               Выражения могут использовать следующие унарные операции:

               -    отрицание (унарный минус);
          тильда    поразрядное дополнение (все биты инвертируются);
               !    логическое "не" (0, если операнд ненулевой, и 1 в про-
                    тивном случае).

               Выражения могут содержать следующие бинарные операции:

               +    сложение
               -    вычитание
               *    умножение
               /    деление
               "    правая, левая кавычки
               &    поразрядное "и"
               |    поразрядное "или"
               ^    поразрядное исключающее "или"
               &&   логическое "и"
               ||   логическое "или"
               >    больше
               <    меньше
               >=   больше или равно
               <=   меньше или равно
               ==   равно
               !=   не равно
               %    остаток от деления
               <<   сдвиг влево
               >>   сдвиг вправо

              Выражение может включать в себя тернарную операцию ?:.

              Операция до ? воспринимается как условие. Если значение это-

         TASM2 #5-5/Док               = 84 =

         го операнда не равно нулю,  то результатом операции является вто-
         рой операнд (то есть тот,  который находится между ?  и :).  Если
         первый операнд равен нулю,  то значением результата этой операции
         является значение третьего операнда (после ?, : и второго операн-
         да).

              Для группирования операндов могут использоваться скобки. При
         их отсутствии порядок выполнения операторов такой же, как в языке
         Ассемблера, а именно:

              * / %         мультипликативные операции
              + -           аддитивные операции
              << >>         операции поразрядного сдвига
              < >           операции отношения
              = !=          операции отношения
              &             поразрядное AND
              ^             поразрядное исключающее "или" (OR)
              |             поразрядное "или" (OR)
              &&            логическое "и" (AND)
              ||            логическое "или"

              Операции равного приоритета выполняются слева направо, кроме
         вложенных тернарных операций ?:, которые выполняются справа нале-
         во.

              Поскольку столько уровней старшинства операций может привес-
         ти к путанице,  мы рекомендуем вам в выражениях чаще использовать
         скобки.

              В выражении  вы  можете вызывать макрокоманду.  Распознается
         специальная макрокоманда $d().  После расширения всех макрокоманд
         выражение должно иметь допустимый синтаксис.




         TASM2 #5-5/Док               = 85 =

                                    Директива error                            
         -----------------------------------------------------------------

              Данная директива вызывает прерывание утилиты MAKE  и  печать
         (вывод на экран) указанного в ней диагностического сообщения.

              Формат:

               !error любой_текст

              Эта директива предназначена для включения в условные  дирек-
         тивы  пользовательских  условий  прекращения выполнения программы
         MAKE. Например,  вы можете исправить предыдущую макрокоманду сле-
         дующим образом:

               !if !$d(MODEL)
               # Если MODEL не определен
               !error MODEL не определено
               !endif

              Если до использовании этой макрокоманды не определили значе-
         ние MDL, то на экране появится сообщение об ошибке:

               Fatal makefile 4: Error directive: MODEL не определено




         TASM2 #5-5/Док               = 86 =

                                                                               
         Директива undef
         -----------------------------------------------------------------

              Данная директива  представляет собой директиву "разопределе-
         ния" макрокоманды.  Имя указанной в ней  макрокоманды  становится
         неопределенным. Если  эта макрокоманда в данный момент не опреде-
         лена, то данная директива не действует.

              Формат: !undef имя_макрокоманды

              Директива отменяет макроопределение. Игнорируется, если мак-
         рокоманда ранее не была определена.

                           Сообщения об ошибках утилиты MAKE                   
         -----------------------------------------------------------------

              Диагностические сообщения  программы  MAKE  могут  быть двух
         типов: сообщения о критических (фатальных) ошибках и сообщения об
         ошибках. При обнаружении фатальной ошибки немедленно прекращается
         обработка формирующего файла.  При обнаружении ошибки интерпрета-
         ция формирующего файла продолжается до его окончания.

              Когда вы встречаете в сообщениях следующее термины,  то под-
         разумевается:

         -----------------------------------------------------------------
              аргументы     аргументы командно строки или другие аргументы
              выражение     выражение
              имя файла     имя файла с расширением или без
              номер строки  номер строки
              сообщение     строка сообщения
         -----------------------------------------------------------------

              Сообщения об  ошибках  приведены в алфавитном порядке (кроме
         тех сообщений,  которые начинаются с имени переменной - они поме-
         щены в начало списка).

                                     Сообщения о фатальных ошибках             
         -----------------------------------------------------------------

              имя_файла does not exist - don't know how make it

         (файл с указанным именем не  существует  -  неизвестно,  как  его
         сформировать)

         TASM2 #5-5/Док               = 87 =


              Это сообщение появляется тогда, когда утилита MAKE встречает
         имя несуществующего файла и нет правила,  с помощью которого дан-
         ный файл можно сформировать.

              Circular dependency exists in makefile

         (в формирующем файле имеется циркулярная зависимость)

              В формирующе файле указывается,  что файл должен  быть новым
         до того, как он построен. Рассмотрим, к примеру, явные правила:

              filea: fileb
              fileb: filec
              filec: filea

              Здесь подразумевается,  что файл filea зависит от fileb, ко-
         торый зависит  от  файла filec.  Это недопустимо,  поскольку файл
         прямо или косвенно не может зависеть сам от себя.

              Error directive: сообщение

         (директива вывода сообщения об ошибке)

              Это сообщение появляется тогда, когда утилита MAKE встречает
         директиву #error в формирующем файле. Текст сообщения из этой ди-
         рективы выводится на экран.

              Incorrect command-line argument: аргумент

         (некорректный аргумент командной строки)

              Это сообщение появляется тогда,  когда утилита MAKE запущена
         с неправильными параметрами командной строки.

              No terminator specified for in-line file operator

         (нет ограничителя для встроенной файловой операции)

              Формирующий файл  содержит  операции  << или &&,  начинающие
         встроенный файл, но этот файл не завершается.

              Not enough memory

         (не хватает памяти)


         TASM2 #5-5/Док               = 88 =

              Данное сообщение появляется тогда,  когда для работы утилиты
         MAKE не хватает памяти. Попытайтесь запустить этот файл на машине
         с большим размером памяти. Если ничего не получается, то надо уп-
         ростить формирующий файл.

              Unable to execute command

         (невозможно выполнить команду)

              Не удается  выполнить  команду.  Это может происходить из-за
         того, что файл не найден,  или его имя неверно указано,  или (что
         менее вероятно) что команда запорчена.

              Unable to execute program

         (программу выполнить невозможно)

              Данное сообщение появляется после попытки выполнения команды
         в том случае, когда командный файл не найден.

              Unable to open makefile

         (невозможно открыть формирующий файл)

              Это сообщение появляется тогда, когда текущий каталог не со-
         держит файл с именем MAKEFILE.

              Unable to redirect input or output

         (невозможно переопределить ввод или вывод)

              Утилита MAKE не смогла открыть временные файлы, необходимые
         для изменения направления ввода или вывода.  Если вы работаете  в
         сети, убедитесь,  что  вы имеете право доступа к соответствующему
         каталогу.




         TASM2 #5-5/Док               = 89 =

                                  Сообщения об ошибках                         
         -----------------------------------------------------------------

              Bad filename format in include statement

         (неверный формат имени файла в операторе include)

              Это сообщение появляется тогда,  когда имя включаемого файла
         не ограничено кавычками.

              Bad undef statement syntax

         (неверный синтаксис оператора !undef)

              Это сообщение  появляется  тогда,  когда  в операторе !undef
         указан неверный операнд.

              Character constant too long

         (символьная константа слишком длинная)

              Это сообщение появляется тогда, когда размер константы более
         2-х цифр.

              Command arguments too long

         (слишком велика длина аргументов командной строки)

              Это сообщение  появляется тогда,  когда длина параметров ко-
         мандной строки превышает 127 байт (ограничение MS-DOS).

              Command syntax error

         (синтаксическая ошибка в команде)

              Это сообщение появляется тогда, когда:

               - первая строка правила начинается с пробелов;
               - подразумеваемое правило не состоит из .ext.ext;
               - явное правило не содержит имени перед знаком (:);
               - макроопределение не содержит имени.

         Command too long

         (команда слишком длинная)


         TASM2 #5-5/Док               = 90 =

              Длина команды превышает  128  символов.  Можно  использовать
         файл подсказок.

              Division by zero

         (деление на 0)

              Это сообщение появляется тогда,  когда в выражении оператора
         !if выполняется деление на ноль.

              Expression syntax in !if statement

         (синтаксис выражения в операторе !if)

              Это сообщение появляется тогда,  когда неправильно сформиро-
         ван  операнд оператора !if (пропущен операнд,  константа,  лишний
         операнд и т.д).

              File name too long

         (слишком длинное имя файла)

              Это сообщение появляется тогда,  когда в директиве  !include
         имя файла содержит более 64-х символов.

              If statement too long

         (слишком длинный оператор If)

              Оператор If превышает 4096 символов.

              Illegal character in constant expression X

         (недопустимая символьная константа в выражении Х)

              Это сообщение появляется тогда, когда утилита MAKE встречает
         в выражении неразрешенные символы.

              Illegal octal digit

         (недопустимая восьмеричная цифра)

              Данное сообщение появляется тогда,  когда восьмеричная конс-
         танта содержит цифры 8 или 9.

              Macro expansion too long

         TASM2 #5-5/Док               = 91 =


         (макрорасширение слишком велико)

              Это сообщение появляется тогда, когда длина макроопределения
         превышает 4096 символов.

              Misplaced elif statement

         (неверный оператор elif)

              Это сообщение появляется тогда, когда  отсутствует директива
         !if для директивы elif.

              Misplaced else statement

         (неверный оператор else)

              Данное сообщение появляется тогда,  когда отсутствует дирек-
         тива !if для директивы else.

              Misplaced endif statement

         (неверный оператор endif)

              Это сообщение появляется тогда,  когда отсутствует директива
         !if для директивы endif.

              No file name ending

         (нет завершения имени файла)

              Данное сообщение   появляется   тогда,   когда  в  директиве
         !include пропущена закрывающая кавычка в поле имени файла.

              Redefinition of target XXXXXXXX

         (переопределение целевого файла ХХХХХХХ)

              Это сообщение появляется тогда,  когда имя файла встречается
         в левой части более чем одного правила.

              Rule line too long

         (строка правила слишком длинная)

              Строка явного или неявного правила превышает 4096 символов.

         TASM2 #5-5/Док               = 92 =


              Unable to open include file XXXXXXXXX.XXX

         (невозможно открыть включаемый файл ХХХХХХХХХ.ХХХ)

              Это сообщение появляется тогда,  когда не найден файл,  ука-
         занный в директиве !include.

              Unexpected end of file in conditional started on line #

         (в условном выражении на строке # обнаружен конец файла)

              Это сообщение появляется тогда, когда исходный файл заканчи-
         вается раньше, чем утилита MAKE встретит директиву !endif.

              Unknown preprocessor statement

         (неизвестный оператор препроцессора)

              Данное сообщение  появляется  тогда,  когда  после символа !
         следует оператор отличный от error,  undef,  if,  elif,  include,
         else или endif.




         TASM2 #5-5/Док               = 93 =

                                        БИБЛИОТЕКАРЬ TLIB                      
         -----------------------------------------------------------------

              Программа TLIB  -  это утилита для управления библиотеками и
         отдельными объектными файлами (библиотекарь).  Библиотекарь  пре-
         доставляет удобный инструмент для работы с набором объектных  мо-
         дулей, как с одним программным модулем.

              Библиотеки, включенные  в  Турбо Ассемблер,  построены с по-
         мощью утилиты TLIB.  Вы можете использовать  данную  утилиту  для
         построения своих собственных библиотек или их модификации, а так-
         же для работы с библиотеками,  построенными другими программиста-
         ми, или приобретенными вами коммерческими библиотеками.

              Библиотекарь ТLIB позволяет:

            - создать библиотеку из отдельных объектных модулей;
            - добавить объектные модули или другие библиотеки в существую-
              щую библиотеку;
            - уничтожить раздел библиотеки;
            - заменить раздел библиотеки;
            - вывести модуль из состава библиотеки;
            - просмотреть оглавление библиотеки.

              При изменении содержимого библиотеки TLIB создает копию  ре-
         дактируемой библиотеки с расширением .BAK.

              TLIB может  также создавать расширенный словарь в библиотеке
         для увеличения скорости редактирования программ (См. параметр /E).

              Хотя утилита  TLIB не является существенной для создания вы-
         полняемых программ на Ассемблере,  ее  использование  значительно
         облегчает труд  программиста  и  повышает его производительность.
         Библиотекарь (и вы в этом  убедитесь)  незаменим  при  разработке
         больших проектов.  Если вы работаете с объектными модулями,  соз-
         данными другими программистами,  данная утилита поможет  вам  при
         необходимости обслуживать подобные библиотеки.




         TASM2 #5-5/Док               = 94 =

                                                                               
         Преимущества использования библиотек объектных модулей
         -----------------------------------------------------------------

              При разработке программа на Ассемблере вам  часто приходится
         создавать набор полезных директив Ассемблера. Обычно эти директи-
         вы разбиваются на несколько раздельно компилируемых исходных фай-
         лов. В  каждой конкретной программе вы можете использовать только
         подмножество функций из всего их набора. Может быть крайне утоми-
         тельным поиск тех конкретных файлов, какие вы используете. С дру-
         гой стороны,  если вы всегда будете включать все файлы,  то прог-
         рамма станет чрезвычайно большой и неэффективной.

              Библиотека объектных  модулей  решает  проблему   управления
         включением  функций  Ассемблера.  При компоновке  программы с ис-
         пользованием библиотеки компоновщик  самостоятельно просматривает
         ее, и автоматически выбирает из нее только те модули, которые не-
         обходимы программе.  К тому же библиотека занимает меньше  памяти
         на диске,  особенно если объектные файлы невелики.  Использование
         библиотек увеличивает скорость трансляции,  так как при доступе к
         ней надо открыть всего один файл, а не несколько.




         TASM2 #5-5/Док               = 95 =

                         Составные части командной строки TLIB                 
         -----------------------------------------------------------------

              Библиотекарь можно вызывать,  набрав команду TLIB в ответ на
         подсказку DOS.  Для получения полного списка  возможностей  TLIB,
         наберите просто TLIB и нажмите клавишу Enter.

              Общая форма вызова TLIB следующая:

            tlib имя_библ [/C] [/E] [/Pразмер][операции][,файл_листинга]

              В этом приложении описывается каждая часть вызова TLIB. При-
         меры приведены в пункте "Примеры".

         -----------------------------------------------------------------
         Компонент                   Описание
         -----------------------------------------------------------------
           tlib              имя для вызова библиотекаря

           имя_библ          Имя создаваемой  или существующей библиотеки.
                             Это имя должно присутствовать всегда.  Специ-
                             альные  символы  недопустимы. Если расширение
                             не указано, то по умолчанию  оно  принимается
                             .LIB.  Если библиотека не существует и выпол-
                             няется операция добавления  модуля,  то  TLIB
                             создает библиотеку.

           /C                Флаг типа букв.  Этот параметр обычно исполь-
                             зуется. См. "Параметр /C".

           /E                Создание  расширенного  словаря. См."Создание
                             расширенного словаря: параметр /E".

           /Pразмер          Устанавливает для страниц  библиотеки указан-
                             ный размер (см. далее).

           операции          Список операций для TLIB. Операции могут сле-
                             довать в любом порядке.

           файл_листинга     Имя файла  листинга  содержимого   оглавления
                             библиотеки.  Перед  именем файла должна нахо-
                             дится запятая. Если вы не укажете имя  файла,
                             то  листинг выводится не будет. Листинг - это
                             алфавитный список модулей вместе с общими пе-
                             ременными, которые в них объявлены.  Расшире-
                             ние  принимаемое по умолчанию для этого файла

         TASM2 #5-5/Док               = 96 =

                             - .LST. Возможно  переопределения  устройства
                             для  вывода  листинга  при помощи стандартных
                             средств DOS. Листинг можно направить  на  эк-
                             ран, указав в качестве имени  файла  листинга
                             CON, или на принтер, задав имя PRN.
         -----------------------------------------------------------------




         TASM2 #5-5/Док               = 97 =

                                    Список операций                            
         -----------------------------------------------------------------

              Список операций описывает действия,  которые необходимо про-
         извести  программе TLIB.  Он состоит из последовательности опера-
         ций, которые следуют одна за другой. Каждая операция  состоит  из
         одно-  или двухсимвольного кода операции,  за которым следует имя
         модуля.

              Пробелы не должны находится ни внутри имени модуля, ни между
         символами  в коде операции. Длина строки - не более 127 символов.
         Порядок операций не имеет значения. Операции выполняются в следую-
         щем порядке:

           1. Сначала  выполняются все операции вывода модуля из библиоте-
              ки.

           2. Затем выполняются все операции уничтожения разделов  библио-
              теки.

           3. Наконец, выполняются все операции добавления в библиотеку.

              Замена модуля равносильна его уничтожению.

                                                                               
         Имя файла и модуля
         ----------------------------------------------------------------

              Когда TLIB добавляет в библиотеку объектный файл,  этот файл
         называется просто  модулем.  TLIB  формирует  имя модуля из имени
         файла, отделяя от него метку диска, маршрут и расширения (которые
         обычно и не указываются).

              Заметим, что  TLIB  использует определенные предположения по
         умолчанию. Например,  чтобы добавить модуль с расширением .OBJ из
         текущего каталога в библиотеку,  вам нужно указать только имя мо-
         дуля без маршрута и расширения.




         TASM2 #5-5/Док               = 98 =

                                     Операции TLIB                             
         -----------------------------------------------------------------

              Программа TLIB использует три символа для обозначения опера-
         ций (-, + и *). Их можно использовать как отдельно, так и вместе.
         Для  тех  операций которые используют два символа для обозначения
         кода операции порядок следования символов не имеет значения. Спи-
         сок операций TLIB приведен ниже:

         -----------------------------------------------------------------
          Код операции    Название            Описание
         -----------------------------------------------------------------
                +        Добавить     TLIB добавляет  файл  в  библиотеку.
                                      Если расширение файла не указано, то
                                      по  умолчанию принимается .OBJ. Если
                                      в качестве исходного  файла  указана
                                      библиотека,  то  разделы из исходной
                                      библиотеки будут добавлены в  другую
                                      библиотеку. Если  уже модуль сущест-
                                      вует в библиотеке,  то  TLIB  выдает
                                      предупреждающее  сообщение и прекра-
                                      щает работу.

               -         Удалить      TLIB  уничтожает  раздел библиотеки.
                                      Если раздел  не  существует, то TLIB
                                      сообщает об этом.

               *         Выделить     TLIB создает файл, копируя раздел из
                                      библиотеки. Если  раздел  библиотеки
                                      не  существует,  то TLIB сообщает об
                                      этом. Если файл уже  существует,  то
                                      он переписывается заново.

               -+        Заменить     TLIB заменяет содержимое раздела биб-
               +-                     лиотеки  на содержимое объектного мо-
                                      дуля.

               -*        Выделить &   TLIB создает файл, копируя раздел из
               *-        Удалить      библиотеки, и уничтожает это  раздел
                                      в библиотеке.
         -----------------------------------------------------------------

              Невозможно средствами TLIB сразу переименовать раздел библи-
         отеки. Для того, чтобы это сделать, надо сначала выполнить опера-
         цию "Выделить & Удалить",  переименовать отдельный файл,  а затем
         выполнить операцию "Добавить" для переименованного файла.

         TASM2 #5-5/Док               = 99 =

                                                                               
         Создание библиотеки
         -----------------------------------------------------------------

              Для того,  чтобы  создать библиотеку, надо просто добавить в
         нее разделы.
                             Использование файлов подсказки                    
         -----------------------------------------------------------------

              Файл подсказки - это простой текстовый файл,  содержащий все
         составные части команды вызова TLIB.  Использование файлов  подс-
         казки позволяет вам использовать больше операндов в команде вызо-
         ва TLIB, чем их помещается в командной строке DOS.

              Для использования файла подсказки в  командной  строке  TLIB
         надо указать @маршрут.

            - Файл  подсказки  может  содержать более одной строки текста.
              Для того,  чтобы указать на продолжение строки,  используйте
              символ амперсанда (&).

            - В этом файле может быть помещена не вся командная строка,  а
              только некотoрая ее часть.

            - В одной командной строке можно использовать несколько коман-
              дных файлов.

              (См. далее примеры.)




         TASM2 #5-5/Док              = 100 =

                       Создание расширенного словаря: параметр /E              
         -----------------------------------------------------------------

              Для увеличения  скорости  компоновки файлов с использованием
         больших библиотек (как,  например, стандартных библиотек Cx.LIB),
         при помощи TLIB вы можете создать расширенный словарь и поместить
         его в библиотеку.  Этот словарь в очень компактной форме содержит
         информацию, которая не включается в стандартный словарь библиоте-
         ки. Она позволяет утилите TLIB быстрее  обрабатывать библиотечные
         файлы,  особенно  если они располагаются на гибких дисках либо на
         медленном жестком диске. Все библиотеки TASM содержат расширенный
         словарь.

              Для того, чтобы создать словарь в модифицируемой  библиотеке
         надо просто  в  командной  строке указать параметр /E.  Если надо
         создать словарь в библиотеке,  содержимое которой не изменяется в
         данный  момент,  то укажите в командной строке опцию /E и команду
         удаления из библиотеки не существующего раздела.  При  этом  TLIB
         выдаст  сообщение  об отсутствии раздела,  но создаст расширенный
         словарь. Например:

                 tlib /E mylib -boqus




         TASM2 #5-5/Док              = 101 =

                         Задание размера страницы: параметр /P                 
         -----------------------------------------------------------------

              Каждый библиотечный файл DOS содержит словарь (который вклю-
         чается к  конец файла .LIB после объектных модулей).  Для каждого
         модуля библиотеки  данный  словарь  содержит  16-разрядный  адрес
         конкретного модуля в файле .LIB. Этот адрес указывается в библио-
         течных страницах (по умолчанию 16 байт).

              Размер страницы определяет максимальный  общий  размер  всех
         объектных модулей  в  библиотеке.  Он  не  может  превышать 65536
         страниц. По умолчанию этот размер равен 16 байт  (это минимальный
         размер), что позволяет формировать библиотеки до 1 мегабайта. Для
         создания библиотеки большего размера размер страницы можно увели-
         чить с  помощью параметра /P.  Этот размер страницы должен предс-
         тавлять собой степень числа 2 и принимать значения в диапазоне от
         16 до 32768.

              Все модули  в библиотеке должны начинаться с границы страни-
         цы. Например,  в библиотеке с размером страницы 32 в среднем  для
         дополнения модулей  в библиотеке будет теряться 16 байт.  Если вы
         пытаетесь создать слишком большую библиотеку для страницы данного
         размера, библиотекарь  выдаст  сообщение  об ошибке и предположит,
         что вы используете в параметре /P  следующее  доступное  значение
         размера.

                                      Параметр /C                              
         -----------------------------------------------------------------

              При добавлении раздела в библиотеку TLIB  проверяет  словарь
         всех общих идентификаторов во всех ее разделах. Все идентификато-
         ры в библиотеке должны быть различны.  Если вы добавляете модуль,
         и он дублирует идентификатор библиотеки,  то такой модуль TLIB не
         добавит и выдаст предупреждающее сообщение.

              Обычно, когда TLIB сравнивает символы,он не  делает  разницы
         между  прописными  и  строчными буквами. Поэтому символы lookup и
         LOOKUP будут восприняты TLIB как одинаковые. Для того, чтобы  от-
         менить этот режим применяется опция /C.

              Может показаться странным, что без параметра /С библиотекарь
         отбрасывает идентификаторы,  которые различаются только регистром
         буквы. Причина  этого заключается в том,  что многие компоновщики
         не различают для идентификаторов в библиотеке регистр букв. Одна-
         ко компоновщик TLINK различает строчные и прописные буквы, и пра-

         TASM2 #5-5/Док              = 102 =

         вильно обрабатывает библиотеку, содержащую идентификаторы, разли-
         чающиеся только регистром буквы.  Например, Турбо Ассемблер будет
         интерпретировать STARS, Stars и stars, как три разных идентифика-
         тора. Если вы пользуетесь компоновщиком TLINK, можете без проблем
         указывать параметр /C.

                                        Примеры                                
         -----------------------------------------------------------------

              Ниже приведены примеры работы с программой TLIB:

           1. Создание библиотеки   MYLIB.LIB  из  модулей  X.OBJ,Y.OBJ  и
              Z.OBJ:

                       tlib mylib +x +y +z

           2. Создание библиотеки MYLIB.LIB и получение листинга:

                       tlib mylib +x +y +z ,mylib.lst

           3. Получение листинга существующей библиотеки CS.LIB:

                       tlib сs,cs.lst

           4. Замена модуля X.OBJ на новую копию, добавление раздела A.OBJ
              и удаление раздела Z.OBJ из библиотеки MYLIB.LIB:

                       tlib mylib -+x +a -z

           5. Создание новой библиотеки с разделами A.OBJ, B.OBJ ... G.OBJ
              при помощи файла подсказки:

              - сначала создадим файл подсказки ALPHA.RSP:

                 +a.obj +b.obj +c.obj &
                 +d.obj +e.obj +f.obj &
                 +g.obj

              - затем используем команду вызова TLIB:

                 tlib alpha @alpha.rsp, alpha.lst

              при этом будет создан файл листинга с именем ALPHA.LST.



         TASM2 #5-5/Док              = 103 =

                                        КОМПОНОВЩИК TLINK                      
         -----------------------------------------------------------------

              Утилита TLINK является отдельной программой и может быть ис-
         пользована как автономный компоновщик (редактор связей). По умол-
         чанию TLINК вызывается после успешной  компиляции  программы  для
         объединения объектных модулей и генерации выполняемого файла.

              В этом приложении описывается использование  утилиты  TLINK,
         как автономного компоновщика.

              При запуске утилиты TLINK без параметров, она выводит на эк-
         ран все параметры. Например:

         TurboLink Version 2.0 Copyright(c)1987,1988 Borland International
            The syntax is: TLINK objfiles, exefile, mapfile, libfiles
            @xxxx indicates use response file xxxx
            Options: /m - map file with publics                    (1)
                     /x - no map file at all                       (2)
                     /i - initialize all segments                  (3)
                     /l - include sourse line numbers              (4)
                     /s - detailed map of segments                 (5)
                     /n - no default libraries                     (6)
                     /d - warn if duplicate symbols in libraries   (7)
                     /c - lowercase significant in symbols         (8)
                     /3 - enable 32-processing                     (9)
                     /v - include full symbolic debug information  (10)
                     /e - ignore Extended Dictionary               (11)
                     /t - create COM-file                          (12)

              1 - файл MAP с общедоступными идентификаторами; 2 - нет фай-
         ла MAP;  3 - инициализировать все сегменты;  4 - включать  номера
         исходных строк; 5 - подробная схема сегментов; 6 - нет используе-
         мых по умолчанию библиотек;  7 - предупреждение  при  обнаружении
         дублирования идентификатора в библиотеке;  8 - различие в иденти-
         фикаторах строчных и прописных букв;  9 - разрешение 32-разрядной
         обработки; 10 - включить полную информацию для отладки;  11 - иг-
         норировать расширенный словарь; 12 - создать файл COM.

              Формат командной строки следующий:

                 TLINK объектные_файлы, выполн_файл, MAP_файл, библиотеки

              Например, вы ввели следующую строку:

                 tlink /c mainline wd ln tx,fin,mfin,lib\comm lib\support

         TASM2 #5-5/Док              = 104 =


              TLINK будет интерпретировать эту строку следующим образом:

            - необходимо учитывать "размер" букв (/c);

            - редактируются объектные файлы: MAINLINE.OBJ,  WD.OBJ,LN.OBJ
              и TX.OBJ;

            - выполняемый файл будет назван FIN.EXE;

            - файл карты загрузки (схемы программы) будет назван MFIN.MAP;

            - во время   редактирования   будут   использованы  библиотеки
              COMM.LIB и SUPPORT.LIB. Они находятся в каталоге LIB.

              Компоновщик TLINK предполагает по умолчанию следующие расши-
         рения для файлов:

            - .OBJ для объектных файлов;
            - .EXE для исполняемых файлов;
            - .MAP для файлов схемы программы;
            - .LIB для библиотек.

              Если вы не определили имя файла .EXE, то оно будет образова-
         но из имени первого объектного файла, при помощи добавления к не-
         му расширения .EXE.

              Когда вы используете параметр /t,  выполняемый файл по умол-
         чанию будет иметь расширение .COM, а не .EXE.

              TLINK всегда генерирует по умолчанию  файл  карты  загрузки,
         если только  вы  явно не указываете,  что этого делать не надо (с
         помощью параметра командной строки /x).

              - Если вы указываете параметр /m, то файл карты загрузки бу-
                дет включать в себя список общедоступных идентификаторов.

              - Если вы задаете параметр /s,  то файл карты загрузки будет
                включать в себя детальную схему сегментов.

              При определении имени файла карты загрузки компоновщик  соб-
         людает следующие правила:

              - Если  вы  не указали файлов .MAP,  компоновщик создает имя
                файла, добавляя расширение .MAP к имени выполняемого  фай-
                ла.  (Имя  выполняемого файла вы можете задать в командной

         TASM2 #5-5/Док              = 105 =

                строке или в файле подсказок.  Если имя выполняемого файла
                не задано, то TLINK будет образовывать его из имени перво-
                го объектного файла.)

              - Если вы указали имя файла карты загрузки в командной стро-
                ке (или  в  файле  подсказок),  то TLINK добавляет к этому
                имени расширение .MAP.

              Вместо косой черты для задания параметров компоновщика можно
         использовать символ -.
                             Использование файлов подсказки                    
         -----------------------------------------------------------------

              Библиотекарь TLINK  позволяет  вам  задавать параметры как в
         командной строке,  так и в файле подсказки,  а также использовать
         сочетание этих методов.

              Файл подсказки - это текстовый файл, содержащий параметры и/
         или имена файлов,  которые вы хотите использовать.  В отличие  от
         командной  строки этот файл может содержать несколько строк текс-
         та. В качестве продолжения строки используется символ (+).

              Вы можете  также  указывать  каждый  из  четырех компонентов
         (объектные файлы,  выполняемый файл, файл карты загрузки, библио-
         теки) на  отдельной  строке.  При этом для разделения компонентов
         все равно нужно использовать запятую.

              Для того,  чтобы продемонстрировать возможности файлов подс-
         казки,  перепишем предыдущую строку в ином виде в файле подсказки
         под именем FINRESP:

               /c mainline wd+
                 ln tx,fin+
                 mfin+
                 lib\comm lib\support

              После этого надо ввести команду:

                 tlink $finresp

              Заметим, что  символ  @ указывает на то,  что имя после него
         является именем файла  подсказки.  Можно  использовать  несколько
         файлов подсказки. Например,  предыдущую  командную  строку  можно
         разбить на четыре файла подсказок:


         TASM2 #5-5/Док              = 106 =

                 Имя файла           Содержимое
                 -------------------------------
                 LISTOBJS            mainline+
                                     wd+
                                     ln tx
                 LISTLIBS            lib\comm+
                                     lib\support
                 -------------------------------

              Теперь вызов утилиты TLINK может иметь следующий вид:

              tlink /c @listobjs,fin,mfin,@listlibs

                                 Параметры компоновщика                        
         -----------------------------------------------------------------

              Параметры компоновщика можно указывать в любом месте команд-
         ной строки.  Параметр состоит из символа / или - (или символа пе-
         реключателя DOS),  за которыми следует соответствующий символ па-
         раметра  (символ переключателя DOS (по умолчанию это /) можно из-
         менить с помощью INT21).

              Если вы  используете  более  одного  параметра,  то  их   не
         обязательно разделять пробелами. Кроме того, их можно указывать в
         разных местах командной строки.  Каждый из параметров более  под-
         робно описывается в следующих разделах.

                               Параметры /x, /m и /s

              По умолчанию компоновщик всегда создает карту  загрузки  вы-
         полняемого файла (схему программы).  Данная карта загрузки содер-
         жит только список сегментов программы, стартовый адрес программы,
         предупреждения и сообщения об ошибках во время работы компоновщи-
         ка.

              Для того,  чтобы отменить генерацию файла .MAP, используется
         параметр /x.

              Параметр /m позволяет создать более  полную  карту  загрузки
         (добавляются  список общих переменных,  отсортированный в порядке
         увеличения адресов). Это необходимо для отладки.

              Параметр /s создает такой же файл карты, как параметр /m, но
         добавляется подробная  схема  сегментов.  Для  каждого сегмента в
         каждом модуле карта включает адрес,  длину в байтах,  его  класс,

         TASM2 #5-5/Док              = 107 =

         имя сегмента, группу, модуль и ACBP информацию. Например, подроб-
         ная схема сегментов может иметь следующий вид:



         TASM2 #5-5/Док              = 108 =

         -----------------------------------------------------------------
          Адрес    Длина   Класс Имя сегмента  Группа  Модуль Выравнивание
                 (в байтах)                                 Комбинирование
         -----------------------------------------------------------------
         0000:0000 0E5B   C=CODE S=SYMB_TEXT  G=NONE   M=SYMB.ASM  ACBP=28
         00E5:000B 2735   C=CODE S=QUAL_TEXT  G=NONE   M=QUAL.ASM  ACBP=28
         0359:0000 002B   C=CODE S=SCOPY_TEXT G=NONE   M=SCOPY     ACBP=28
         035B:000B 003A   C=CODE S=LRSH_TEXT  G=NONE   M=LRSH      ACBP=20
         035F:0005 0083   C=CODE S=PADA_TEXT  G=NONE   M=PADA      ACBP=20
         0367:0008 05СE   C=CODE S=PADD_TEXT  G=NONE   M=PADD      ACBP=20
         036D:0003 0025   C=CODE S=PSBR_TEXT  G=NONE   M=PSBR      ACBP=20
         036F:0008 05CE   C=CODE S=BRK_TEXT   G=NONE   M=BRK       ACBP=28
         03CC:0006 066F   C=CODE S=FLOAT_TEXT G=NONE   M=FLOAT     ACBP=20
         0433:0006 000B   C=DATA S=_DATA      G=DGROUP M=SYMB.ASM  ACBP=48
         0433:0012 00D3   C=DATA S=_DATA      G=DGROUP M=QUAL,ASM  ACBP=48
         0433:00E6 000E   C=DATA S=_DATA      G=DGROUP M=BRK       ACBP=48
         0442:0004 0004   C=BSS  S=_BSS       G=DGROUP M=SYMB.ASM  ACBP=48
         0442:0008 0002   C=BSS  S=_BSS       G=DGROUP M=QUAL.ASM  ACBP=48
         0442:000A 000E   C=BSS  S=_BSS       G=DGROUP M=BRK       ACBP=48
         -----------------------------------------------------------------

              Для каждого сегмента в каждом модуле данная схема включает в
         себя адрес,  длину сегмента в байтах, его класс, имя, группу, мо-
         дуль и информацию ACBP.

              Сокращение ACBP расшифровывается,  как  A  (выравнивание)  и
         C (комбинирование).  Эта  информация занимает четыре бита.  TLINK
         использует только два из них - A и C. В файле .MAP эта информация
         приводится в шестнадцатиричном виде. Значения полей в ACBP - при-
         ведены ниже:

         -----------------------------------------------------------------
           Поле           Значение         Описание
         -----------------------------------------------------------------
         Поле A             00    Абсолютный сегмент
         (Выравнивание)     20    Сегмент, выровненный на границу байта
                            40    Сегмент, выровненный на границу слова
                            60    Сегмент, выровненный на границу параграфа
                            80    Сегмент, выровненный на границу страницы
                            A0    неименованный абсолютный участок памяти
         Поле B             00    Не комбинируется
         (Комбинирование)   08    Общий комбинируемый сегмент
         -----------------------------------------------------------------

              Если один и тот же сегмент встречается в нескольких модулях,
         то каждый модуль будет указываться на отдельной строке (например,

         TASM2 #5-5/Док              = 109 =

         SYMB.C).
                                                                               
                                     Параметр /l

              Параметр /l (номера строк) создает раздел в файле  .MAP  для
         номеров строк исходного кода. Для того, чтобы использовать данный
         параметр, необходимо компилировать исходный файл с параметров -y.
         Если  вы задали параметр компоновщика -x (не создавать карту), то
         параметр / l будет игнорироваться.
                                                                               
                                     Параметр /i

              Параметр /i (неинициализированные конечные сегменты) помеща-
         ет сегменты в выполняемый файл,  даже если они не содержат записи
         данных. Заметим, что обычно это не требуется.
                                                                               
                                     Параметр /n

              Параметр /n (игнорирование используемых по умолчанию библио-
         тек) приводит к тому,  что компоновщик игнорирует библиотеки, ус-
         тановленные по умолчанию для некоторых компиляторов.  Этот  пара-
         метр необходим в том случае,  когда библиотеки расположены в дру-
         гом каталоге.
                                                                               
                                     Параметр /c

              Параметр /c (различимость на регистр букв) задает такой  ре-
         жим,  при  котором  прописные и строчные буквы в именах внешних и
         общих переменных различаются.  Например,  если  до  использования
         этого параметр TLINK воспринимал имена fred, Fred и FRED как оди-
         наковые, то после ее использования эти имена будут разными.
                                                    Параметр /d                

              Обычно TLINK  не  предупреждает  о  том,  что  идентификатор
         встречается более чем в одной библиотеке. Если идентификатор дол-
         жен  быть включен в программу,  то TLINK будет использовать копию
         этого идентификатора из первого  файла,  указанного  в  командной
         строке.

              Предположим, у  вас  имеется  две библиотеки:  SUPPORT.LIB и
         DEBUGSUP.LIB.  Пусть также библиотека DEBUGSUP.LIB содержит подп-
         рограммы,  находящиеся и в SUPPORT.LIB.  Тогда, если вы в команде
         вызова TLINK первой укажете библиотеку DEBUGSUP.LIB,  то подпрог-
         раммы  из  SUPPORT.LIB  под  такими же именами в выполняемый файл
         включены не будут.

         TASM2 #5-5/Док              = 110 =


              Параметр /d  (дублирование идентификаторов) приводит к тому,
         что компоновщик строит список одинаковых идентификаторов в библи-
         отеках, даже если они не используются в программе.

              Параметр /d также приводит к тому,  что TLINK будет выдавать
         предупреждение в   том  случае,  если  одинаковые  идентификаторы
         встречаются как в .OBJ - файле, так и в библиотеке. В этом случае
         идентификатор будет взят из файла .OBJ.

              Предположим, у вас имеется две  библиотеки,  одна  с  именем
         SUPPORT.LIB, и  дополнительная  библиотека с именем DEBUGSUP.LIB.
         Предположим также, что эта последняя библиотека содержит дублика-
         ты некоторых  подпрограмм библиотеки SUPPORT.LIB (но работают они
         несколько по-другому,  как отладочные версии данных подпрограмм).
         Если в командной строке компоновщика вы сначала указываете библи-
         отеку DEBUGSUP.LIB,  то вы получите отладочные подпрограммы, а не
         версии, содержащиеся в SUPPORT.LIB.

              Если вы не используете данное средство,  или не уверены нас-
         чет того,  какие именно подпрограммы дублируются, можно использо-
         вать параметр /d. При этом компоновщик составит список всех иден-
         тификаторов, дублирующихся в библиотеках,  даже если они не будут
         использованы в программе.

              При указании  данного  параметра TLIB будет также предупреж-
         дать об идентификаторах, встречающихся как в файле .OBJ,  так и в
         файле .LIB.  В этом случае, так как идентификатор, содержащийся в
         файле, указанном в командной строке левее,  будет тем идентифика-
         торов, который  участвует  в компоновке,  то использоваться будет
         тот идентификатор, который содержится в файле .OBJ.

              Библиотеки, поставляемые с Турбо  Ассемблером,  не  содержат
         никаких дублирующих идентификаторов.  Поэтому, так как библиотеки
         EMU.LIB и FP87.LIB (CS.LIB и CL.LIB) очевидно содержат  дублирую-
         щиеся идентификаторы,  вам не следует использовать их в одной ко-
         мандной строке. В библиотеках EMU.LIB,  MATH.LIB и CS.LIB, напри-
         мер, нет идентификаторов-дубликатов.
                                                    Параметр /e                

              Библиотеки, используемые в Турбо Ассемблере и Турбо Си,  со-
         держат расширенный словарь (Extended Dictionary),  который позво-
         ляет утилите  TLINK сократить время компоновки.  Расширенный сло-
         варь может быть помещен в любую библиотеку при  помощи  параметра
         /E. Использование  параметра  /e  запрещает использование данного

         TASM2 #5-5/Док              = 111 =

         словаря.

              Хотя компоновка программ с использованием расширенного  сло-
         варя выполняется  быстрее,  вы  можете пожелать запретить его ис-
         пользование, если у вас есть программа,  для компоновки которой с
         использованием расширенного  словаря  требуется  несколько больше
         памяти.
              Если вы  используете  параметр /e,  TLINK будет игнорировать
         отладочную информацию,  включенную в библиотеку, которая содержит
         расширенный словарь.

              Таким образом,  использованию расширенного словаря могут по-
         мешать два обстоятельства:

            - для редактирования  программы  с использованием расширенного
              словаря не хватает памяти;

            - TLINK будет игнорировать любую отладочную информацию, содер-
              жащуюся в библиотеке с расширенным словарем.
                                                                               
                                     Параметр /t

              Если вы задали в файле сверхмалую модель памяти (TINY) и ис-
         пользуете этот параметр (задающий сверхмалую модель памяти и файл
         .COM), то вместо выполняемого  файла  .EXE  будет  генерироваться
         файл .COM.

              Примечание: Размер  файлов .COM не может превышать 64К,  они
         не могут содержать относительных корректировок сегментов, опреде-
         лять сегмент  стека,  и  должны  иметь  начальный  адрес,  равный
         0:100H. Когда для выполняемого файл используется расширение,  от-
         личное от .COM (например, .BIN), то начальный адрес может быть 0:
         0 или 0:0100H.
                                                                               
                                     Параметр /v

              Параметр /v указывает компоновщику TLINK на то,  что необхо-
         димо включение  в  выполняемый  файл отладочной информации.  Если
         этот параметр указывается в каком-либо  месте  командной  строки,
         отладочная информация  будет  включена во все модули,  которые ее
         содержат. Для разрешения или запрещения включения отладочной  ин-
         формации вы  можете использовать параметры /v+ или /v-. Например,
         при использовании команды:
                                                                               
                 tlink mod1 /v+ mod2 mod3 /v- mod4


         TASM2 #5-5/Док              = 112 =

         отладочная информация включается в модули  mod2  и  mod3,  но  не
         включается в mod1 и mod4.
                                                                               
                                     Параметр /3

              Параметр /3  (32-разрядный  код процессора 80386) должен ис-
         пользоваться тогда, когда один и более объектный модуль (получен-
         ный с помощью TASM или совместимого с ним Ассемблера,  генерирую-
         щего код для процессора 80386) содержит 32-разрядный код для мик-
         ропроцессора 80386. Этот параметр должен использоваться только по
         мере необходимости,  так как он сильно влияет на скорость  компо-
         новки и увеличивает объем памяти, необходимой для нее.




         TASM2 #5-5/Док              = 113 =

                                                                               
         Ограничения
         -----------------------------------------------------------------

              На самом деле TLINK имеет только одно серьезное ограничение:
         он не генерирует выполняемые файлы Windows или OS/2.

              Перечислим существовавшие ранее ограничения,  которые теперь
         не имеют места:

              - не поддерживаются общие переменные;

              - сегменты с одинаковым именем и классом должны быть все ли-
                бо доступны, либо недоступны;

              - TLINK несовместим с компоновщиком LINK фирмы Microsoft.

              TLINK, конечно,  можно  использовать с другими компиляторами
         фирмы Borland.

                                                                               
         Сообщения об ошибках
         -----------------------------------------------------------------

              Диагностические сообщения программы TLINK  могут  быть  трех
         классов: сообщения  о критических (фатальных) ошибках,  сообщения
         об ошибках и предупреждения:

            - при обнаружении фатальных ошибок TLINK немедленно прекращает
              работу, а файлы .EXE и .MAP уничтожаются;

            - при обнаружении ошибок файлы .EXE и .MAP  остаются, но вы не
              должны пытаться запускать .EXE файл.

            - предупреждения означают просто сообщения об условиях,  кото-
              рые вы можете захотеть скорректировать.  При генерации  пре-
              дупреждающего сообщения файлы .EXE и .MAP создаются.

              Сообщения об  ошибках  приведены в алфавитном порядке (кроме
         тех сообщений,  которые начинаются с имени переменной - они поме-
         щены в начало списка).




         TASM2 #5-5/Док              = 114 =

                             Сообщения о фатальных ошибках                     
         -----------------------------------------------------------------

         имя_файла: bad object file

         (неверный объектный файл)

              Это сообщение появляется тогда, когда TLINK встречает объек-
         тный файл неправильного формата.

         имя_файла: unable to open file

         (невозможно открыть файл)

              Это сообщение появляется тогда, когда файл не существует.

         группа: group exceeds 64K

         (группа превышает 64К)

              Данное сообщение выводится, когда при комбинировании сегмен-
         тов в группу группа превышает 64К.

         (группа превышает 64К)

              Данное сообщение выводится, когда при комбинировании сегмен-
         тов в группу группа превышает 64К.

         модуль: bad .obj file, virtual LEDATA with no VirDef

         (модуль: неверный объектный файл, вирт. LEDATA без VirDef)

              Данное сообщение указывает на ошибку в отладочной информации
         объектного файла.  Компилятор генерирует неверный объектный файл,
         либо объектный файл запорчен.

         модуль: bad .obj file, virtual reference with no VirDef

         (плохой объектный файл, виртуальная ссылка без VirDef)

              Данное сообщение указывает на ошибку в отладочной информации
         объектного файла.  Компилятор генерирует неверный объектный файл,
         либо объектный файл запорчен.

         сегмент: segment exceed 84K


         TASM2 #5-5/Док              = 115 =

         (сегмент превышает 64К)

              Данное сообщение  выводится,  если для данного сегмента кода
         или данных определено слишком много  данных  (при  комбинировании
         сегментов из разных исходных файлов с одним именем).

         Bad character in parameters

         (неверный символ в параметрах)

              Это сообщение появляется тогда, когда либо в командной стро-
         ке, либо  в файле подсказки встречается один из следующих симво-
         лов:

               "   *   <  =  >  ?  [  ]  !

         либо любой управляющий символ (горизонтальная  табуляция, возврат
         каретки или Ctrl-Z).

         Cannot generate COM file: data below initial CS:IP defined

         (невозможно сгенерировать файл .COM,  определены данные ниже  на-
         чального значения CS:IP)

              Данная ошибка происходит в результате попытки генерации дан-
         ных или кода ниже начального адреса файла COM (обычно 100).  Убе-
         дитесь, что  начальный  адрес установлен с помощью инструкции ORG
         100H в значение 100.  При разработке программ на  языке  высокого
         уровня данная  ошибка  не должна возникать.  Если она происходит,
         убедитесь, что компонуются корректные объектные модули  инициали-
         зации (C0).

         Cannot generate COM file: invalid initial entry point address

         (невозможно сгенерировать файл .COM: недопустимый начальный адрес
         точки входа)

              Вы использовали параметр /t, но начальный адрес программы не
         равен 100h, как это требуется для файлов .COM.

         Cannot generate CON file: program exceed 64K

         (невозможно сгенерировать  файл .COM:  размер программы превышает
         64К)

              Вы использовали параметр /t,  но общий размер программы пре-

         TASM2 #5-5/Док              = 116 =

         вышает предел для файла .COM.

         Cannot generate COM file: segment relocatable item present

         (невозможно сгенерировать файл .COM: присутствует элемент с пере-
         мещаемым сегментом)

              Вы использовали параметр /t, но программа не может содержать
         относительные корректировки  сегментов (они не допускаются в фай-
         лах .COM).

         Invalid entry point offset

         (недопустимое смещение точки входа)

              Данное сообщение появляется только при компоновке  модулей с
         32-разрядными записями. Это означает, что начальное смещение точ-
         ки входа программы превышает ограничение DOS в 64К.

         Invalid group definition in mmodule модуль

         (недопустимое определение группы в модуле)

              Данная ошибка возникает при попытке присвоить  сегмент более
         чем одной группе. Она может также возникать при неправильном фор-
         мировании записи GRPDEF в объектном файле. Последний случай может
         возникать при работе с пользовательскими объектными файлами,  по-
         лученными с помощью нестандартных  компилятором,  или  вызываться
         ошибкой в трансляторе, используемом для получения объектного фай-
         ла.

         Invalid initial stack offset

         (недопустимое начальное смещение стека)

              Данное сообщение выводится только при компоновке  модулей  с
         32-разрядными записями. Это означает, что начальное значение ука-
         зателя стека превышает ограничение DOS в 64К.

         Invalid segment definition in module модуль

         (недопустимое определение сегмента в модуле)

              Данное сообщение обычно выводится,  если компилятор  создает
         неправильный объектный файл.  Если это происходит для файла, соз-
         данного компилятором Турбо Си, перекомпилируйте данный файл. Если

         TASM2 #5-5/Док              = 117 =

         ошибка остается, свяжитесь с фирмой Borland.

         Invalid switch in parameter block

         (недопустимый переключатель в блоке параметров)

             Эта ошибка  возникает  из-за  логической ошибки в TLINK или в
         интегрированной среде разработки.

         Msdos error, ax=XXXXh

         (ошибка DOS, ax=XXXXh)

              Это сообщение появляется тогда, когда при вызове MS-DOS про-
         исходит неизвестная ошибка.  При этом печатается  содержимое  ре-
         гистра AX.  Данное сообщение может указывать на внутреннюю ошибку
         DOS. Когда  возникает эта ошибка TLINK может выполнять вызовы DOS
         по чтению, записи, позиционированию и закрытию.

         Not enough memory

         (не хватает памяти)

              Это сообщение появляется тогда,  когда не хватает памяти для
         компоновки.  Необходимо освободить память от резидентных программ
         и повторить вызов TLINK,  либо уменьшить размер псевдодиска (если
         он используется).

         Not enough memory to link

         (недостаточно памяти для компоновки)

              Для выполнения TLINK требуется не менее 145К свободной памя-
         ти. Попытайтесь освободить память,  выгрузив резидентные програм-
         мы.

         Relocation offset overflow in module модуль

         (данная ошибка  возникает только при компоновке 32-разрядных объ-
         ектных модулей  и  показывает,  что   относительное   перемещение
         (корректировка сегмента) превышает ограничение DOS в 64К.

         Relocation table full

         (компонуемый файл  содержит  больше  базовых  корректировок,  чем
         может содержать стандартная таблица перемещений DOS (базовые кор-

         TASM2 #5-5/Док              = 118 =

         ректировки создаются  в основном вызовами к функциям дальнего ти-
         па).

         Segment exceeds 64K

         (сегмент превышает 64К)

              Это сообщение появляется тогда, когда размер сегмента превы-
         шает 64 Кбайта при компоновке нескольких сегментов  с одинаковыми
         именами.

         Symbol limit exceeded

         (превышено пространство идентификаторов)

              Это сообщение  появляется тогда,  когда превышено количество
         общих идентификаторов,  имен сегментов или имен групп  (их  может
         быть не более 8182).

         Table limit exceeded

         (превышено ограничение таблицы)

              Данное сообщение происходит  из-за  переполнения  внутренней
         таблицы идентификаторов  компоновщика.  Обычно это означает,  что
         компонуемая  программа превысила мощность компоновщика для  обще-
         доступных или внешних идентификаторов.

         32-bit record encountered in module модуль: use "/3" option

         (в модуле  обнаружена  32-разрядная запись,  используйте параметр
         /3)

              Данное сообщение возникает,  когда обнаружен объектный файл,
         содержащий 32-разрядные записи для процессора 80386,  а  параметр
         /3 не используется.  Перезапустите компоновщик с указанным  пара-
         метром.

         Unexpected group definition

         (непредвиденное определение группы)

              В объектном файле определения групп должны следовать в стро-
         гом порядке.  Это сообщение появляется тогда, когда TASM сгенери-
         ровал некорректный файл. Перетранслируйте исходный файл.


         TASM2 #5-5/Док              = 119 =

         Unexpected segment definition

         (непредвиденное определение сегмента)

              В объектном  файле  определения сегментов должны следовать в
         строгом порядке.  Это сообщение появляется тогда, когда TASM сге-
         нерировал некорректный файл. Перетранслируйте исходный файл.

         Unknown option

         (неизвестный параметр)

            Это сообщение появляется тогда, когда в командной строке после
         символа (/) не следует параметр.

         Write failed, disk full ?

         (запись выполнить нельзя, диск переполнен)

              Это сообщение появляется тогда,  когда TLINK не может  запи-
         сать  данные на диск.  Обычно это происходит при записи на запол-
         ненный диск.



         TASM2 #5-5/Док              = 120 =

                                                                               
         Сообщения об ошибках
         -----------------------------------------------------------------

              При работе  с  компоновщиком TLINK могут возникать следующие
         некритических ошибки.  Как уже упоминалось, при возникновении та-
         кой ошибки файлы .EXE и .MAP не удаляются.  При работе в интегри-
         рованной среде программирования  данные  ошибки  рассматриваются,
         как критические (фатальные).
                                                                               
         XXX is unresolved in module YYY

         (неудовлетворенная ссылка XXX в модуле YYY)

              Это сообщение  появляется тогда,  когда в модуле есть ссылка
         на неопределенный идентификатор  (то есть  на  идентификатор,  не
         содержащийся ни в файлах .OBJ,  ни в библиотеках, подключенных на
         время компоновки).
                                                                               
         Fixup overflow, frame = xxxxh, target = xxxxh,
         offset=xxxxh  module XXXXXXXX

         (переполнение  корректировок,  граница =xxxxh, цель=xxxxh, смеще-
         ние=xxxxh модуль ХХХХХХХХ)

              Это сообщение указывает на то,  что в загруженном для компо-
         новки модуле неправильные данные, либо неправильная ссылка. В по-
         ле Fixup находится имя,  на которое производится ссылка,  а также
         имя сегмента, где оно должно находится. Значение поля frame - это
         сегмент,  где должно находиться имя в объектном файле.  Значением
         поля target является сегмент,  в котором находится это имя в нас-
         тоящее время.  В поле offset  указано  смещение  внутри  сегмента
         target для имени.

              Это сообщение  часто появляется при неправильном определении
         моделей памяти, а также если генерируется near-вызов для перемен-
         ной.  Для того, чтобы разобраться в причинах, вызвавших это сооб-
         щение,  необходимо получить карту (map) загрузочного  модуля  при
         помощи параметра /m. По значениям target и offset надо найти имя,
         на которое производится ссылка.  Если это сделать не удалось,  то
         надо взять имя, ближайшее к этому адресу. Затем выяснить по текс-
         ту исходного модуля в чем же дело.
                                                                               
         Out of memory

         (превышение границ памяти)


         TASM2 #5-5/Док              = 121 =

              Данная ошибка возникает, когда TLINK превысил предел исполь-
         зования памяти.  Обычно это означает, что в компонуемых объектных
         файлах используется слишком  много  модулей,  определено  слишком
         много сегментов, групп, внешних ссылок.
                                                                               
         Undefined symbol <идентификатор> in module <модуль>

              На указанный  идентификатор  имеется ссылка в данном модуле,
         но он не определен в наборе объектных файлов и  библиотек,  вклю-
         ченных в компоновку. Проверьте и убедитесь, что имя идентификато-
         ра указано корректно. Обычно эта ошибка наблюдается для идентифи-
         каторов Турбо  Си,  если  вы не укажите правильно описания pascal
         и cdecl в разных исходных файлах,  либо пропустите имя объектного
         файла, который требуется вашей программе.



         TASM2 #5-5/Док              = 122 =

                                     Предупреждения                            
         -----------------------------------------------------------------

         Warning: symbol defined in module модуль is duplicated  in module
         модуль

         (идентификатор данного модуля дублируется в другом модуле)

              Идентификатор определен  в каждом из указанных модулей.  Это
         может произойти,  когда в одной командной строке  объектный  файл
         указывается дважды.

         Warning: no stack

         (нет стека)

              Это предупреждающее  сообщение появляется тогда,  когда ни в
         одном из компонуемых файлов не определен сегмент стека. Это обыч-
         ное явление  для программ со сверхмалой моделью памяти (TINY) или
         для программ,  преобразуемых в формат .COM. Для остальных моделей
         памяти - это ошибка.

         Warning: no stub for fixup in модуль at сегмент:xxxxh

         (нет промежуточного сегмента для корректировок в указанном модуле
         и сегменте)

              Это сообщение появляется,  когда целевой сегмент для коррек-
         тировок находится в оверлейном сегменте, а для сегмента не найде-
         но промежуточного сегмента.  Обычно это  является  результатом  в
         оверлее общедоступного идентификатора,  на который имеется ссылка
         в том же модуле.

         Warning: segment сегмент is in two groups: группа1 and группа2

         (указанный сегмент содержится в двух группах)

              Компоновщик обнаружил конфликтную ситуацию  для  двух  групп
         сегментов.




         TASM2 #5-5/Док              = 123 =

                                     Утилита TOUCH                             
         -----------------------------------------------------------------

              Бывают случаи,  когда нужно перекомпилировать конкретный це-
         левой файл или перестроить его, даже если не осуществлялись изме-
         нения в его исходных файлах.  Одним из средств,  позволяющих осу-
         ществить это является обслуживающая программа TOUCH, включенная в
         Турбо  Ассемблер.  Обслуживающая  программа TOUCH заменяет дату и
         время одного или нескольких файлов на текущие дату и время, делая
         таким образом этот файл более новым, чем файлы от него зависящие.

              Чтобы перестроить  целевой  файл,  примените эту программу к
         одному из файлов,  от которых зависит целевой файл.  Чтобы приме-
         нить  данную программу к файлу (или файлам),  после подсказки DOS
         введите:

              touch имя_файла [ имя_файла... ]

              Обслуживающая программа TOUCH после этого изменит даты  соз-
         дания файлов.

              После этого можно вызвать обслуживающую программу МАКЕ, что-
         бы перестроить обработанные таким образом файлы.  (При  работе  с
         обслуживающей  программой  TOUCH  можно  пользоваться глобальными
         символами имени файла ДОС * и ?.)



         TASM2 #5-5/Док              = 124 =

                               Параметры командной строки                      
         -----------------------------------------------------------------

          -a                     Генерирует автоматическую проверку  зави-
                                 симостей.

          -Dидентификатор
                                 Определяет указанный  идентификатор   как
                                 строку, содержащую единственный символ 1.

          -Dидентификатор=строка Определяет указанный   идентификатор  как
                                 строку со значением,  стоящим после знака
                                 равенства (=).  Строка не может содержать
                                 пробелы или символы табуляции.

          -Iкаталог              Утилита MAKE будет искать включаемые фай-
                                 лы в этом каталоге.

          -Uидентификатор        Отменяет макроопределение с именем "иден-
                                 тификатор".

          -s                     Обычно утилита MAKE печатает  те команды,
                                 которые выполняются.  Этот параметр отме-
                                 няет печать команд.

          -n                     Заставляет утилиту MAKE  печатать команды
                                 не  выполняя  их.  Эта опция используется
                                 для отладки формирующего файла.

          -fимя_файла            Использует "имя_файла" в  качестве  имени
                                 формирующего файла.

          -? или -h              Печать подсказки.



         TASM2 #5-5/Док              = 125 =

                                                                               
                     GREP: УТИЛИТА ПОИСКА ТЕКСТА В ФАЙЛАХ
         -----------------------------------------------------------------

                    Примечание: Данная  утилита  описывается также в файле
               на дистрибутивном диске Турбо Ассемблера,  где может содер-
               жаться информация о последних ее изменениях, не описанных в
               данном руководстве,  поэтому обратитесь также к  указанному

              GREP - это мощная утилита поиска, которая может искать текст
         в нескольких файлах сразу.

              Общий вид синтаксиса строки для вызова GREP следующий:

              grep [параметры] строка_поиска имя_файла [имя_файла ...
                имя_файла]

              Например, если вы хотите узнать, в каких файлах использовали
         функцию setupmodem,  то можно использовать утилиту GREP следующим
         образом:

                 grep setupmodem *.asm
                                 Параметры утилиты GREP                        
         -----------------------------------------------------------------

                    Примечание: Данная  утилита  описывается также в файле
               на дистрибутивном диске Турбо Ассемблера,  где могут содер-
               жаться информация о последних ее изменениях, не описанных в
               данном руководстве,  поэтому обратитесь также к  указанному

              Для утилиты GREP параметры - это один или несколько  одиноч-
         ных  символов,  которым предшествует символ (-).  Каждый символ -
         это переключатель,  который может быть либо "включен", либо "вык-
         лючен".  "Включение" производится символом плюс (+),  а "выключе-
         ние" - минус (-).  Эти символы следуют после параметра  командной
         строки (например -r+ или -r -). Если действие с переключателем не
         указано,  то по умолчанию предполагается (+).  Возможно  задавать
         параметры следующим образом (вместо -i-d-l можно -ild или -il-d).
         Ниже приведен список параметров и их назначение:

            -c           Только счетчик: будет печатать  только количество
                         найденных строк.  Для  каждого  файла,  в котором
                         найдена строка,  будет напечатано имя файла и ко-
                         личество строк. Сами строки не печатаются.

            -d           Каталоги:  для  каждого имени файла, определенно-

         TASM2 #5-5/Док              = 126 =

                         го в командной строке, утилита GREP ищет все фай-
                         лы с таким же именем, как в определенном директо-
                         рии,  так и во всех подкаталогах в этом каталоге.
                         Если  вы  указали имя файла без указания маршрута
                         поиска,  то утилита GREP ищет его в текущем ката-
                         логе.

            -i           Игнорирование различий между прописными и  строч-
                         ными буквами.

            -l           Просмотр файлов, в которых найдена  строка:  GREP
                         выводит только имена этих файлов.

            -n           Каждый файл, имя которого GREP печатает  сопровож-
                         дается номером.

            -o           Формат вывода для UNIX. Изменение  формата вывода
                         для облегчения  использования в операционной сис-
                         теме UNIX.

            -r           Поиск выражений.  Текст,  определенный как строка
                         поиска, воспринимается как выражение.

            -u           Опция изменения: GREP объединяет заданные  в  ко-
                         мандной строке опции с параметрами,  заданными по
                         умолчанию и записывает все параметры в файл GREP.
                         COM как новые значения  параметров,  используемых
                         по умолчанию.

            -v           Печатаются только  те строки, которые не содержат
                         строку поиска.

            -w           Поиск слов: текст будет найден, если значение вы-
                         ражения  будет совпадать и предыдущая и следующая
                         буква не будут частями слова. Набор символов  для
                         слов по умолчанию содержит A-Z,  0-9 и (_).  Аль-
                         тернативная форма этой  директивы  позволяет  вам
                         задать новый набор символов. Ее синтаксис:

                                -w[набор]

                         где набор - любое правильное определение  набора.
                         Если  набор определяется при помощи букв алфавита,
                         то автоматически определяются как прописные,  так
                         и строчные буквы, независимо от того, является ли
                         поиск зависимым от размера букв или нет.  Если вы

         TASM2 #5-5/Док              = 127 =

                         используете параметр -w  совместно  с  параметром
                         -u, то новый набор заменит старый, принимаемый по
                         умолчанию.

            -z           GREP печатает  имя  файла  для каждого найденного
                         файла. Каждой строке предшествует  номер  строки.
                         Также приводится счетчик найденных строк в каждом
                         файле.

                                                                               
         Порядок следования
         -----------------------------------------------------------------

              Имейте в виду, что каждый параметр утилиты GREP - переключа-
         тель.  В  любой  момент  времени  каждый параметр может быть либо
         включен,  либо выключен. Каждое появление данного параметра в ко-
         мандной строке отменяет его предыдущее значение. Например:

               grep -r- -i -d- -i -r- main  (my *.asm

              После ввода  этой строки утилита GREP будет запущена со сле-
         дующими параметрами (-d -включена,  -i - включена ,  -r -выключе-
         на).

              При помощи  параметра  -u вы можете встроить параметры,  ис-
         пользуемые по умолчанию, в утилиту GREP.COM.




         TASM2 #5-5/Док              = 128 =

                                                                               
         Строка поиска
         -----------------------------------------------------------------

              Значение строки поиска определяет образец,  по которому ути-
         лита GREP производит поиск.  Строка поиска может быть как обычным
         выражением  так  и  строкой литер.  В обычном выражении отдельные
         символы имеют специальное назначение - они управляют  поиском.  В
         символьной строке  нет  операторов - каждый символ воспринимается
         как литера.

              Вы можете  заключить строку поиска в кавычки для того, чтобы
         предотвратить восприятие пробелов и табуляций, как разделителей.

              Выражение - это или отдельный  символ  или  набор  символов,
         заключенный в скобки. Конкатенация обычных выражений есть обычное
         выражение.




         TASM2 #5-5/Док              = 129 =

                             Операторы в обычных выражениях                    
         -----------------------------------------------------------------

              Когда вы используете параметр -r,  строка поиска воспринима-
         ется  как обычное выражение и следующие символы имеют специальное
         предназначение:

               ^  в начале  выражения  этот  символ  соответствует  началу
                  строки.

               $  в конце выражения этот знак соответствует концу строки.

               .  этот символ соответствует любому символу.

               *  выражение,за которым следует этот  разделитель, соответ-
                  ствует  нескольким  появлениям этого выражения. Например
                  в fo* он соответствует f,  fo,  foo и т.д и т.п.,  но не
                  соответствует fa.

               +  выражение, за которым следует этот разделитель, соответ-
                  ствует  нескольким появлениям этого выражения.  Например
                  fo+ соответствует fo, foo и т.д. и т.п., но не f.

               [] строка, заключенная в скобки, соответствует любому  сим-
                  волу в этой строке. Если первым символом в строке  явля-
                  ется символ (^), то эта строка соответствует любому сим-
                  волу, за  исключением  символов,  содержащихся в строке.
                  Например,  [xyz] соответствует x,y,z, а [^xyz] соответс-
                  твует  a и b,  а не x,y или z.  Вы можете определить ряд
                  символов при помощи двух  символов,  разделенных  знаком
                  (-).

               \  этот символ сообщает GREP, что надо искать символ, кото-
                  рый следует за этим символом.

                    Замечание. Четыре из ранее определенных символов ($,.,
               * и +) не имеют специального назначения,  если используются
               внутри скобок. Дополнительно, символ ^ воспринимается толь-
               ко как специальный символ,  если непосредственно следует за
               началом определения набора символов (то есть за [).




         TASM2 #5-5/Док              = 130 =

                                                                               
         Спецификация файла
         -----------------------------------------------------------------

              Третья часть командной строки утилиты GREP - это определение
         файла. Оно сообщает утилите GREP, в каких файлах (группах файлов)
         искать строку. Определение файла может быть как определенным име-
         нем файла, так и обобщенным именем файла (при помощи символов ? и
         *).  Вы  также можете указать и путь как часть определения файла.
         Если путь не указан,то GREP ищет только в текущем каталоге.

                                 Примеры с пояснениями                         
         -----------------------------------------------------------------

              Все следующие примеры предполагают, что по умолчанию все па-
         раметры утилиты GREP выключены:

               Пример 1:
               ---------

            Командная строка  :   grep start: *.asm

            Будет искать      :   start:
                                  restart

            Не будет искать   :   restarted:
                                  ClockStart:

            Где будет искать  :   В файлах  с  расширением  .ASM в текущем
                                  каталоге.

            Замечания         :   По умолчанию, прописные и строчные буквы
                                  различаются.

               Пример 2:
               ---------

            Командная строка  :   grep -r [^a-z]main\ "{" *.asm

            Будет искать      :   main {i:integer}
                                  main {i,j:integer}
                                  if (main () halt ;

            Не будет искать   :   mymain {}
                                  MAIN (i:integer);


         TASM2 #5-5/Док              = 131 =

            Где будет искать  :   В файлах с расширением  .ASM  в  текущем
                                  каталоге.

            Замечания         :   Строка поиска  сообщает  GREP,  что надо
                                  искать слово main без предшествующих ему
                                  строчных букв ([^a-z]), за которым  сле-
                                  дуют пробелы (\*) и левая скобка.

              Так как  пробелы  и  знаки табуляции обычно воспринимаются в
         командной строке как разделители, вы должны заключить их в кавыч-
         ки для того, чтобы включить в выражение.

               Пример 3:
               ---------

            Командная строка  :    grep -ri [a-c]:\\data\.fil *.asm *.inc

            Будет искать      :    A:data.fil
                                   c:Data.Fil
                                   B:\DATA.FIL

            Не будет искать   :    d:data.fil
                                   a:data:fil

            Где будет искать  :    В файлах *.ASM и *.INC в текущем  ката-
                                   логе.

            Замечания         :    Так как  символы (\) и (.) обычно имеют
                                   специальное значение, и если Вы  хотите
                                   искать эти символы, то необходимо перед
                                   каждыми  из этих символов дополнительно
                                   указать символ (\).

               Пример 4:
               ---------

            Командная строка  :    grep -ri [^a-z]word[^a-z] *.doc

            Будет искать      :    every new word must be on a new line
                                   MY WORD !
                                   word--smallest unit of speech.
                                   In the beginning there was WORD, and
                                   the WORD

            Не будет искать   :    Each file has at least 2000 words.
                                   He misspells toward as toword.

         TASM2 #5-5/Док              = 132 =


            Где будет искать  :    В файлах *.DOC в текущем каталоге.

            Замечания         :    Этот формат обычно определяет, как  ис-
                                   кать данное слово.

               Пример 5:
               ---------

            Командная строка  :    grep -iw word *.doc

            Будет искать      :    every new word must be on a new line
                                   However, MY WORD !
                                   word: smallest unit of speech which
                                   conveys meaning
                                   In the beginning there was WORD, and
                                   the WORD

            Не будет искать   :    Each file has at least 2000 words.
                                   He seems to continually mispell "toward"
                                   as "toword."

            Где будет искать  :    В файлах *.DOC в текущем каталоге.

            Замечания         :    Этот формат  определяет основной  поиск
                                   "слов".

               Пример 6:
               ---------

            Командная строка  :    grep "search  string with spaces" *.doc
                                   *.asm a:\work\myfile.*

            Будет искать      :    This is  a search string with spaces in
                                   it

            Не будет искать   :    THIS IS A SEARCH STRING WITH SPACES  IN
                                   IT

                                   This is   a  search  string  with  many
                                   spaces in it.

            Где будет искать  :    В файлах *.DOC и *.ASM в текущем  ката-
                                   логе и в  файлах  MYFILE.*  в  каталоге
                                   WORK на дисководе A.


         TASM2 #5-5/Док              = 133 =

            Замечания         :    Это пример  того,  как  искать  строку,
                                   включающую пробелы.

               Пример 7:
               ---------

            Командная строка  :    grep -rd "[,.:?'\"]"$ \ *.DOC

            Будет искать      :    He said hi to me
                                   Where are you going
                                   Happening in anticipation of unique
                                   situation
                                   Examples include the following :
                                   "Many men smoke, but fu man chu."

            Не будет искать   :    He said "Hi" to me
                                   Where are you going? I'm headed to the
                                   beach this

            Где будет искать  :    В файлах *.DOC в  текущем  каталоге,  и
                                   во всех  подкаталогах на текущем диске.

            Замечания         :    В этом примере производится поиск  сим-
                                   волов  в  конце  строки.  Заметим,  что
                                   двойным кавычкам (") предшествует  сим-
                                   вол  (\) поэтому (") воспринимаются как
                                   обычный символ, а не как  конец  строки
                                   поиска.

               Пример 8:
               ---------

            Командная строка  :    grep -ild " the " \*.doc
                                   или
                                   grep -i -l -d " the " \*.doc
                                   или
                                   grep -il -d " the " \*.doc

            Будет искать      :    Anyway, this is the time we have
                                   do you think? The main reason we are

            Не будет искать   :    He said "Hi" to me just when I
                                   Where are you going ? I'll bet you're
                                   headed to

            Где будет искать  :    В файлах  *.DOC в  текущем  каталоге, и

         TASM2 #5-5/Док              = 134 =

                                   во всех  подкаталогах на текущем диске.

            Замечания         :    В этом примере игнорируется размер букв
                                   и  только печатается имена любых файлов
                                   содержащих, по крайней мере  один  раз,
                                   строку поиска.



         TASM2 #5-5/Док              = 135 =

                           OBJXREF: УТИЛИТА ДЛЯ РАБОТЫ С ПЕРЕКРЕСТНЫМИ         
                            ССЫЛКАМИ В ОБЪЕКТНЫХ МОДУЛЯХ
         -----------------------------------------------------------------

              Утилита OBJXREF - это утилита, которая проверяет список объ-
         ектных  файлов  и  библиотек и выдает отчет об их содержимом.

                    Примечание: Данная  утилита  описывается также в файле
               на дистрибутивном диске Турбо Ассемблера,  где может содер-
               жаться информация о последних ее изменениях, не описанных в
               данном руководстве,  поэтому обратитесь также к  указанному

              Один тип  отчета  -  это  список общих имен и ссылки на них.
         Другой тип отчета - список  размеров  сегментов,  определенных  в
         объектных модулях.

              Существует две категории общих имен: глобальные переменные и
         имена функций. В разделе "Простые отчеты OBJXREF" приведены прог-
         раммы  TEST1.ASM  и  TEST2.ASM,  иллюстрирующие определение общих
         имен и внешних ссылок на них.

              Объектные модули - это  объектные  (.OBJ)  файлы,  созданные
         компилятором Турбо Си TCC или TASM. Библиотечные файлы (.LIB) со-
         держат несколько объектных модулей. Объектные модули, которые ге-
         нерирует TASM,имеют то же имя, что и исходный модуль с расширени-
         ем .ASM, если только вы не указали другое имя в командной строке.

                            Командная строка утилиты OBJXREF                   
         -----------------------------------------------------------------

              Командная строка  OBJXREF состоит из слова OBJXREF, за кото-
         рым следуют несколько опций командной строки и список имен объек-
         тных и библиотечных файлов, разделенных пробелами или знаками та-
         буляции. Синтаксис командной строки следующий:

                   OBJXREF <параметры> имя_файла <имя_файла>

              Параметры командной строки определяют  тип  отчета,  который
         будет сгенерирован утилитой OBJXREF,  а также степень его детали-
         зации.

              Каждый параметр начинается со знака (/),  за которым следует
         одно или двухсимвольное имя параметра.

              Объектные файлы и библиотеки могут быть определены как в ко-

         TASM2 #5-5/Док              = 136 =

         мандной строке, так и в файле подсказки. В командной строке имена
         файлов разделяются пробелами или символами табуляции. Все объект-
         ные модули, определенные как файлы .OBJ, включаются в отчеты. По-
         добно программе TLINK,  OBJXREF включает только модули из библио-
         теки, содержащие имена,  на котoрые ссылаются модули  .OBJ,  либо
         ранее включенные модули из библиотеки.

              Имена файлов  могут включать имена дисковода и маршрут.  Для
         определения более одного файла могут быть использованы  специаль-
         ные (трафаретные) символы DOS ? и *. Имена файлов могут относить-
         ся к файлам .OBJ или файлам .LIB (если не задано расширение  фай-
         ла, то по умолчанию используется расширение .OBJ).

              Параметры и  имена файлов могут следовать в командной строке
         в любом порядке.

              Отчет, сгенерированный утилитой OBJXREF,  выводится на стан-
         дартное устройство вывода DOS (по умолчанию - на экран).  При по-
         мощи символа переназначения DOS (>) возможно вывести отчет как на
         печать (>LPT1:), так и в файл (>имя файла).

              Если утилита  запускается  без  указания параметров или имен
         файлов, то OBJXREF выведет полный список доступных параметр.

                       Параметры командной строки утилиты OBJXREF              
         -----------------------------------------------------------------

              Параметры командной  строки  утилиты  OBJXREF делятся на две
         категории: управляющие параметры и параметры отчетов.

                               Управляющие параметры

              Управляющие параметры изменяют  поведение  утилиты  OBJXREF,
         принимаемое  по умолчанию (сначала по умолчанию принимается,  что
         все параметры разрешены):

              /I     Игнорирование различий между прописными  и  строчными
                     буквами в  общих именах.  Используйте этот параметр в
                     том случае,  когда вы вызывали компоновщик TLINK  без
                     параметра /c.

              /F     Включение библиотек полностью. Все объектные модули в
                     определенной библиотеке включаются даже в том случае,
                     когда  объектный  модуль,   обрабатываемый   утилитой
                     OBJXREF, не содержит ссылок на  общие идентификаторы,

         TASM2 #5-5/Док              = 137 =

                     определенные в модулях библиотеки. Этот параметр поз-
                     воляет получить полную информацию о содержимом библи-
                     отеки (См.  пример 4 в разделе "Примеры использования
                     утилиты OBJXREF").

              /V     Вывод полной информации. Выдача полного списка  общих
                     имен, модулей, сегментов и классов.

              /Z     Включение сегментов с нулевой длиной. В объектных мо-
                     дулях могут быть определены сегменты, для которых  не
                     отводится память.

                                 Параметры отчетов

              Параметры отчетов  управляют  типом генерируемого отчета,  а
         также степенью его детализации:

              /RC    Отчет о типах классов: размеры модулей упорядочены по
                     типу класса сегмента.

              /RM    Отчет о модуле: вывод общих имен, находящихся в моду-
                     ле.

              /RP    Отчет об общих именах: вывод общих имен вместе с име-
                     нем определенного модуля.

              /RR    Отчет  о ссылках: вывод определений общих имен и ссы-
                     лок, упорядоченных по имени.

              /RS    Отчет о размере модуля: вывод размера модулей, упоря-
                     доченных по имени модуля.

              /RU    Сообщение об общих  именах,  на  которых  отсутствуют
                     ссылки.

              /RV    Полный отчет: OBJXREF генерирует отчет каждого типа.

              /RX    Отчет о внешних ссылках: вывод внешних ссылок, упоря-
                     доченных по имени модуля, на который идет ссылка.




         TASM2 #5-5/Док              = 138 =

                                    Файлы подсказок                            
         -----------------------------------------------------------------

              Размер командной  строки  ограничен  в MS-DOS 128 символами.
         Если размер командной строки превышает предельную величину, то вы
         можете разместить имена файлов в файле  подсказки  (response-фай-
         ле). Файл  подсказки  (или  файл ответов) - это простой текстовый
         файл,  который может быть создан при помощи текстового редактора.
         Утилита OBJXREF может использовать различные типы файлов подсказ-
         ки.

              Файлы подсказки вызываются из командной строки при помощи од-
         ного из параметров. Имя файла должно следовать непосредственно за
         параметров (без пробелов. Например: /Lresp, а не /L resp).

              В одной командной строке может быть использовано более одно-
         го файла подсказки,  и дополнительно в командной строке могут ис-
         пользоваться имена файлов .OBJ и .LIB.

                           Произвольные файлы подсказки

              Для использования файла подсказки с  утилитой  OBJXREF  надо
         указать  его имя в командной строке.  Имени должен предшествовать
         символ (@).  Имя файла должно быть отделено от имен других файлов
         пробелами, либо символами табуляции:

                     @имя файла  @имя файла ...

                    Замечание: Для  любого  файла,  имя которого указано в
               файле подсказки без расширения, по умолчанию подразумевает-
               ся расширение .OBJ.

                                  Файлы подсказки

              Возможно также использование файлов подсказки,  ранее подго-
         товленных для компоновщика (TLINK). Файл подсказки такого формата
         вызывается при помощи параметра /L:

                 /Lимя_файла

              Для того, чтобы узнать, как использовать файлы подсказки, вы
         можете обратиться к Примеру 2 в  разделе  "Примеры  использования
         утилиты OBJXREF".

                                    Команда /O


         TASM2 #5-5/Док              = 139 =

              Если вы хотите, чтобы утилита OBJXREF выполнила действия над
         объектными файлами, которые находятся в каталоге, отличном от те-
         кущего, то надо определить требуемый  каталог  при помощи команды
         /O. Например:

                 /Omyobjdir

                                    Команда /N

              Если вы хотите ограничить количество имен  модулей,  сегмен-
         тов, классов, и внешних имен в отчетах утилиты OBJXREF, то должны
         указать эти имена в командной строке после команды  /N. Например,
         строка:

                  OBJXREF <список_файлов> /RM /Test

         сообщит утилите, что необходимо игнорировать отчет только для мо-
         дуля с именем Test.




         TASM2 #5-5/Док              = 140 =

                             Простые отчеты утилиты OBJXREF                    
         -----------------------------------------------------------------

              Предположим, что у вас имеются два исходных файла, и вы хо-
         тите при помощи OBJXREF сгенерировать отчеты по объектным файлам,
         полученным в результате компиляции исходных файлов. Эти файлы на-
         зываются TEST1.ASM и TEST2.ASM и выглядят следующим образом:

            ;TEST1.ASM
                   .MODE SMALL
                   STACK 200h

                   EXTRN GOODBYE:BYTE
                   EXTRN SAYHELLO:NEAR

                   PUBLIC HELLO
                   PUBLIC NOTUSED

            .DATA
            HELLO         DB       'HELLO',10,13,'$'
            NOTUSED       DW       ?
            HIDDEN        DW       ?

            .CODE
            SAYBYE        PROC     NEAR
                          mov      dx,OFFSET GOODBYE
                          mov      ah,9
                          INT      21h

                          RET
            SAYBYE        ENDP

            START         PROC     NEAR
                          mov      ax,@data
                          mov      ds,ax
                          CALL     SAYHELLO
                          CALL     SAYBYE

            EXIT:

                          mov       ax,04COOh
                          INT       21h
            START         ENDP
            END           START

            ; TEST2.ASM

         TASM2 #5-5/Док              = 141 =


                         .MODEL     SMALL
                         EXTRN      HELLO:BYTE
                         PUBLIC     GOODBYE
                         PUBLIC     SAYHELLO

            .DATA
            GOODBYE      DB         'Goodbye',10,13,'$'

            .CODE
            SAYHELLO                PROC      NEAR
                         mov        dx,OFFSET   HELLO
                         mov        ah,9
                         INT        21h
                         RET
            SAYHELLO                ENDP
            END

              Объектные модули, полученные при компиляции исходных файлов,
         имеют соответственно имена TEST1.OBJ и TEST2.OBJ. Для того, чтобы
         получить требуемый вам отчет об этих объектных файлах, необходимо
         указать их имена в командной строке после /RX, где  X  определяет
         тип генерируемого отчета.

                    Замечание. Приведенные  ниже   примеры   демонстрируют
               только фрагменты выходных данных.



         TASM2 #5-5/Док              = 142 =

                                                                               
         Отчет об общих именах (/RP)
         -----------------------------------------------------------------

              В этом отчете содержаться все общие  имена,  определенные  в
         объектных  модулях и имена модулей, в которых эти имена определе-
         ны. Если вы введете следующую командную строку:

                     OBJXREF /RP test1 test2

         то утилита OBJXREF выдаст отчет следующего вида:

                   ------------------------------------------
                   Идентификатор            Определен в
                   ------------------------------------------
                       GOODBYE              TEST2
                       HELLO                TEST1
                       NOTUSED              TEST1
                       SAYHELLO             TEST2
                   ------------------------------------------





         TASM2 #5-5/Док              = 143 =

                                  Отчет о модуле (/RM)                         
         -----------------------------------------------------------------

              Этот отчет содержит имена всех заданных  объектных  модулей,
         за  которыми следуют имена общих имен, объявленных в этом модуле.
         Если вы введете следующую командную строку:

                     OBJXREF /RM test1 test2

         то утилита OBJXREF выдаст отчет следующего вида:

                 Module: TEST1 defines the following symbols:

                          HELLO
                          NOTUSED

                 Module: TEST2 defines the following symbols:

                          GOODBYE
                          SAYHELLO

         (Утилита сообщает,  что в модуле определены следующие идентифика-
         торы.)

                                                                               
         Отчет о ссылках (/RR) (по умолчанию)
         -----------------------------------------------------------------

              В этом отчете содержаться имена общих имен и в этой же стро-
         ке в скобках находится имя модуля с этим общим именем. На следую-
         щей строке приводятся имя модулей,  которые  ссылаются  на  общее
         имя. Если вы введете следующую командную строку:

                     OBJXREF /RR test1 test2

         то утилита OBJXREF выдаст отчет следующего вида:

              GOODBYE (TEST2)
                      TEST1
              HELLO   (TEST1)
                      TEST2
              NOTUSED (TEST1)
              SAYHELLO (TEST2)
                       TEST1



         TASM2 #5-5/Док              = 144 =

                                                                               
         Отчет о внешних ссылках (/RX)
         -----------------------------------------------------------------

              В этом отчете содержатся имена модулей, за которыми  следуют
         внешние  ссылки, определенные в этом модуле. Если вы введете сле-
         дующую командную строку:

                     OBJXREF /RX test1 test2 CS.LIB,

         то OBJXREF выдаст отчет следующего вида:

             Module: TEST1 references the following symbols :

               GOODBYE
               SAYHELLO

             Module: TEST2 references the following :

               HELLO

         (Утилита сообщает,  что модуль ссылается на следующие идентифика-
         торы.)

                             Отчет о размерах модулей (/RS)                    
         -----------------------------------------------------------------

              В этом отчете содержатся имена сегментов, за которыми следу-
         ет список модулей, в которых определен этот сегмент. Размер  при-
         водится  в байтах в десятичном и шестнадцатиричном представлении.
         Тогда когда ни одному идентификаторы в сегменте заранее не  прис-
         ваивается  значение,  то  после имени сегмента присутствует слово
         uninitialized (неинициализирован). Если сегмент является абсолют-
         ным  (то есть настроен на определенный адрес оперативной памяти),
         то слева от размера сегмента присутствует слово Abs.

              Если вы введете следующую командную строку:

                     OBJXREF /RS test1 test2

              то OBJXREF выдаст отчет следующего вида:

              ;Module sizes by segment
                STACK
                            512 (00200h) TEST1,unitialized
                            512 (00200h) total

         TASM2 #5-5/Док              = 145 =


                _DATA
                            12  (0000Ch) TEST1
                            10  (0000Ah) TEST2
                            22  (00016h) total

                _TEXT
                            24  (00018h) TEST1
                            8   (00008h) TEST2
                            32  (00020h) total

                              Отчет о типах классов (/RC)                      
         -----------------------------------------------------------------

              В этом отчете приводятся определения  сегментов  по  классам
         сегментов. Класс CODE содержит исполняемые инструкции, класс DATA
         -  инициализированные  данные, а класс BSS - неинициализированные
         данные. Сегменты, не имеющие класса, будут приведены под заголов-
         ком "No class type" (нет типа класса).

              Если вы введете следующую командную строку:

                     OBJXREF /RC test1 test2

         то утилита OBJXREF выдаст отчет следующего вида:

              ;Module sizes by class
                CODE
                            24  (00018h) TEST1
                            8   (00008h) TEST2
                            32  (00020h) total

                DATA
                            12  (0000Ch) TEST1
                            10  (0000Ah) TEST2
                            22  (00016h) total

                STACK
                            512 (00200h) TEST1,unitialized
                            512 (00200h) total

                   Отчет об общих именах, на которые нет ссылок (/RU)          
         -----------------------------------------------------------------


         TASM2 #5-5/Док              = 146 =

              В этом отчете приводятся  имена  модулей,  содержащие  общие
         имена,  на которые отсутствуют ссылки из других модулей. Возможны
         два случая:

            - на этот идентификатор имеются ссылки внутри модуля  (в  этом
              случае данный  идентификатор не должен объявляться,  как об-
              щий);

            - на идентификатор совсем нет ссылок (в этом случае этот иден-
              тификатор надо удалить).

              Если вы введете следующую командную строку:

                     OBJXREF /RU test1 test2

         то утилита OBJXREF выдаст отчет следующего вида:

             Module :

                TEST1 defines the following unreferenced symbols :

                NOTUSED

         (В модуле  TEST1 определены следующие идентификаторы,  на которые
         отсутствуют ссылки.)

                                                                               
         Полный отчет (/RV)
         -----------------------------------------------------------------

              При указании  этого параметра в командной строке для каждого
         модуля будет генерироваться отчет каждого перечисленных выше  ти-
         пов.

                         Примеры использования утилиты OBJXREF                 
         -----------------------------------------------------------------

              Предполагается, что обрабатываемые файлы находятся в текущем
         каталоге на  текущем  дисководе,  а библиотечные файлы в каталоге
         \LIB.

            Пример 1:     C>OBJXREF test1 test2 \lib\io.lib

                         Дополнительно к файлам TEST1.OBJ и TEST2.OBJ  оп-
                         ределен  библиотечный  файл  \LIB\IO.LIB. Так как

         TASM2 #5-5/Док              = 147 =

                         тип отчета не определен,  то по умолчанию генери-
                         руется отчет о ссылках.

            Пример 2:     C>OBJXREF /RV /Ltest1.arf

                         Файл подсказки программы TLINK TEST1.ARF содержит
                         командную строку, аналогичную строке в Примере 1.
                         Файл TEST1.ARF содержит следующие данные:

                             test1 test2
                             test1.exe
                             test1.map
                             \lib\io  .

                         Так как задан параметр /RV,  то  для  каждого  из
                         указанных  .OBJ и .LIB файлов утилита OBJXREF бу-
                         дет генерировать отчет каждого типа.

            Пример 3:     C>OBJXREF /F /RV /LIB\IO.LIB

                         В этом  примере  отчеты  будут  сгенерированы для
                         всех модулей из библиотеки IO.LIB.




         TASM2 #5-5/Док              = 148 =

                    Предупреждающие сообщения и сообщения об ошибках           
                          утилиты OBJXREF
         -----------------------------------------------------------------

              Утилита OBJXREF  генерирует два типа диагностических сообще-
         ний: сообщения об ошибках и предупреждающие сообщения.

                                Сообщения об ошибках

         Out of memory

         (выход за границы памяти)

              Утилита выполняет все операции в оперативной памяти, поэтому
         иногда она не может выполняться даже в том случае, в котором ути-
         лита TLINK будет работать с тем же списком файлов. Для выполнения
         программы  OBJXREF  необходимо  освободить  память от резидентных
         программ.

                             Предупреждающие сообщения

         WARNING: Unable to open input file rrrr

         (невозможно открыть входной файл rrrr)

              Входной файл rrrr не найден или не может быть открыт. Утили-
         та OBJXREF переходит к обработке следующего файла.

         WARNING: Unknown option - oooo

         (неизвестный параметр oooo)

              Имя параметра  oooo не распознано утилитой OBJXREF.  Утилита
         игнорирует данный параметр.

         WARNING: Unresolved symbol nnnn in module mmmm

         (идентификатор с неудовлетворенными ссылками в модуле mmmm)

               Общее имя nnnn в модуле mmmm не определено в любом из  фай-
         лов .OBJ  или .LIB.  Утилита OBJXREF помечает эти идентификаторы,
         как неопределенные, и на них имеются ссылки.

         WARNING: Invalid file specification ffff

         (недопустимая спецификация файла ffff)

         TASM2 #5-5/Док              = 149 =


              Некоторая часть  имени  файла  ffff  неправильная.   Утилита
         OBJXREF переходит к обработке следующего файла.

         WARNING: No files matching ffff

         (нет соответствующих файлов ffff)

              Файл ffff, приведенный в командной строке либо в файле подс-
         казки, не найден, не может быть открыт. Утилита OBJXREF переходит
         к обработке следующего файла.

         WARNING: Symbol nnnn defined in mmmm1 duplicated in mmmm2

         (идентификатор nnnn определен в mmmm1 и дублируется в mmmm2)

              Общее имя  nnnn определено в модулях mmmm1 и mmmm2.  Утилита
         OBJXREF игнорирует второе определение.




         TASM2 #5-5/Док              = 150 =

            TCREF: УТИЛИТА РАБОТЫ С ПЕРЕКРЕСТНЫМИ ССЫЛКАМИ ИСХОДНЫХ МОДУЛЕЙ    
         -----------------------------------------------------------------

                    Примечание: Данная  утилита  описывается также в файле
               на дистрибутивном диске Турбо Ассемблера,  где может содер-
               жаться информация о последних ее изменениях, не описанных в
               данном руководстве,  поэтому обратитесь также к  указанному
               файлу.

              Утилита OBJXREF предназначена для  генерации  двух  отчетов:
         списка перекрестных ссылок, в котором указывается, где глобальные
         идентификаторы определены и где используются,  и списка отдельных
         модулей и идентификаторов, которые используются внутри них.

              Утилита TCREF обрабатывает  группу  файлов  .XRF,  созданных
         программой TASM.  Эти файлы содержат информацию для отдельных мо-
         дулей.  Из этих файлов создается один файл .REF,  содержащий один
         или несколько отчетов. Формат команды следующий:

          TCREF <файлы_.XRF, разделенные '+'>','<файл_.REF><переключатели>

              Например:

                TCREF foo1+foo2+foo3,foo
                                                                               
         Файлы подсказок
         -----------------------------------------------------------------

              Утилита TCREF воспринимает  текстовые  файлы  как  командные
         строки.  Для  того,  чтобы использовать файлы в командной строке,
         надо указать в ней имя файла с символом (@) перед  ним. Например:

                      TCREF @DoFoo

         где файл DoFoo содержит следующую информацию:

                      foo1+foo2+foo3,foo
                                                                               
         Совместимость с утилитой TLINK
         -----------------------------------------------------------------

              Утилита TCREF воспринимает командные строки программы TLINK.
         Эта утилита игнорирует все не относящиеся к делу  переключатели и
         поля командной  строки,  а также любые библиотеки или файлы .MAP,
         предназначенные для выполнения компоновки. Если файлы .XRF не мо-
         гут быть найдены, утилита TCREF будет просто игнорировать их.

         TASM2 #5-5/Док              = 151 =


                    Будьте осторожны!  При  использование  файла подсказки
               программы TLINK особое внимание обратите на расширение  вы-
               ходного  файла.  Например,  если  в файле подсказки утилиты
               TLINK явно указано расширение выходного файла:

                     foo1+foo2+foo3,foo.exe

               то при использовании этого файла с  программой  TCREF  ваша
               программа будет испорчена.

                                                                               
         Переключатели
         -----------------------------------------------------------------

              Утилита TCREF воспринимает  все  переключатели  компоновщика
         TLINK, но большинство из них он не поддерживает. TCREF использует
         такие переключатели:

            - /c  в отчете о глобальных идентификаторах (GLOBAL) игнориру-
                  ется регистр символов;

            - /r  генерирует  отчеты  о локальных идентификаторах (LOCAL)
                  для всех определенных модулей;

            - /p# устанавливает высоту страницы отчета в # строк;
            - /w# устанавливает ширину страницы отчета в # позиций.

                                  Выходная информация                          
         -----------------------------------------------------------------

              Информация о перекрестных ссылках выдается для исходных фай-
         лов и с номерами исходных строк.

                        Отчет о глобальных идентификаторах

              В этом отчете глобальные идентификаторы выводятся в алфавит-
         ном порядке слева. Ссылки на идентификатор в исходном файле нахо-
         дятся  справа.  Символ  # указывает на то,  что определение этого
         идентификатора было в строке с таким номером. Например:

            Global Symbols       Cref # = definition
            BAR                  TEST.ASM : 1  3  6  9  12  15  18 +
                                                        21  23  29
                                                 # TEST2.ASM : 2  4  6  #8

         TASM2 #5-5/Док              = 152 =


              Символ # перед TEST2.ASM показывает,  что имя идентификатора
         BAR определено внутри модуля TEST2.ASM. Список может занимать бо-
         лее одной строки.  Если строка списка переносится на другую стро-
         ку, то в конце предыдущей строки ставится  символ  (+).  Наконец,
         символ # перед цифрой 8 показывает,  что имя BAR определено в мо-
         дуле TEST2.ASM в строке 8.

                         Отчет о локальных идентификаторах

              Если вы задали в командной строке параметр /r,  то программа
         будет генерировать для каждого из модулей отчет о локальных иден-
         тификаторах. Он будет содержать все  идентификаторы, определенные
         в модуле, упорядоченные по алфавиту. Для этого типа отчета соблю-
         даются те же соглашения,  что и для отчета о глобальных идентифи-
         каторах. Например:

            Module TEST.ASM Symbols   Cref # = definition
            UGH                       TEST.ASM:  1  3  6  9  12  15  18  +
                                                             21  23  29
                                                      #UGH.INC: #2




         TASM2 #5-5/Док              = 153 =

                                                                               
                  ПРИЛОЖЕНИЕ E.  СООБЩЕНИЯ ОБ ОШИБКАХ.
         -----------------------------------------------------------------

              В этом  приложении описаны все сообщения, которые генерирует
         Турбо Ассемблер TASM.  Сообщения обычно появляются на экране,  но
         Вы можете выводить их в файл на диске,  используя стандартный ме-
         ханизм переопределения устройств DOS. Например:

              TASM MYFILE > ERRORS

              TASM генерирует следующие типы сообщений:

            - информационные сообщения;
            - предупреждающие сообщения;
            - сообщения об ошибках;
            - сообщения о фатальных ошибках.

                                                                               
         Информационные сообщения
         -----------------------------------------------------------------

              Турбо Ассемблер TASM генерирует два  информационных  сообще-
         ния, одно в начале ассемблирования файла, а другое при завершении
         ассемблирования. Эти сообщения имеют следующий вид:

         TurboAssembler Version2.00 Copyright(C)1990 Borland International
         Assembling file: TEST.ASM

              При завершении  ассемблирования  выдается  сообщение  о  его
         итогах:

           Error messages: None        (число ошибок)
           Warning messages: None      (число предупреждений)
           Remaining memory: 279k      (объем свободной памяти)

              Эти сообщения могут быть подавлены при помощи параметра  ко-
         мандной  строки /T.  Но если во время трансляции возникли ошибки,
         то данный параметр будет игнорироваться.




         TASM2 #5-5/Док              = 154 =

                         Предупреждения и сообщения об ошибках                 
         -----------------------------------------------------------------

              Предупреждающие сообщения появляются тогда, когда вы  допус-
         тили  незначительную ошибку в операторах исходного текста. Однако
         даже такие ошибки могут существенно влиять на работу вашей  прог-
         раммы,  поэтому необходимо каждый раз проверять причину, по кото-
         рой предупреждающее сообщение было выдано. Предупреждения не  ос-
         танавливают процесс генерации объектного файла. Они имеют следую-
         щий формат:

          ** Warning ** имя_файла (строка) сообщение

              Если предупреждающее  сообщение  встречается  в  макросе или
         блоке повторения,  то дополнительно выводится информация об имени
         макрокоманды и номера строки внутри нее:

          ** Warning ** имя_файла (строка) имя_макроком.(строка) сообщение

              В отличие  от предупреждений,сообщения об ошибках останавли-
         вают генерацию объектного файла, но ассемблирование  продолжается
         до достижения конца файла. Типичный формат  сообщения  об  ошибке
         следующий:

          ** Error ** имя_файла (строка) сообщение

              Если сообщение об ошибке встречается в макрокоманде или бло-
         ке  повторения,  то  дополнительно  выводится информация об имени
         макроса и номера строки внутри него:

          ** Error ** имя_файла (строка) имя_макроком. (строка) сообщение

              Ниже приведены  предупреждающие  сообщения  и  сообщения  об
         ошибках:

                                                                               
         Arguments need types override
         (в аргументах требуется переопределение типов)

              Это сообщение появляется тогда,  когда в выражении необходим
         операнд определенного размера или типа,  и тип (размер)  операнда
         не может быть определен из контекста. Например:

                mov  bx,1

              Вы можете  исправить  эту ошибку при помощи явного указателя

         TASM2 #5-5/Док              = 155 =

         типа (размера) операнда. Например:

                mov  WORD PTR [bx],1

                                                                               
         Argument to operation or instruction has illegal size
         (аргументы операции или инструкции имеют недопустимый размер)

              Это сообщение появляется тогда, когда операция не определена
         для данного типа операнда. Например:

              Q LABEL QWORD
              QNOT = NOT Q  ; нельзя взять отрицание от типа данных qword

                                                                               
         Arithmetic overflow
         (арифметическое переполнение)

              Это сообщение появляется тогда,  когда происходит переполне-
         ние вычислении значения выражения. Например:

              X = 20000 * 20000   ; переполнение 32-х бит

              Все вычисления выполняются в 32-разрядном формате.

                                                                               
         ASSUME must be segment register
         (в ASSUME должен указываться сегментный регистр)

              Это сообщение появляется тогда,  когда в директиве ASSUME вы
         указали регистр, отличный от сегментного. Например:

                 ASSUME ax:CODE

                                                                               
         Assuming segment is 32 bit
         (предполагается использование 32-разрядного сегмента)

              Это сообщение появляется тогда, когда вы открыли сегмент при
         помощи директивы SEGMENT после того,  как разрешили ассемблирова-
         ние инструкций для микропроцессора 80386, но не определили размер
         указателя сегмента при помощи директивы USE16 или USE32.

            В этом  случае  TASM  предполагает,  что  размер  указателя  -
         32-разрядный.


         TASM2 #5-5/Док              = 156 =

                                                                               
         Bad keyword in SEGMENT statement

         (неверное ключевое слово в операторе SEGMENT)

            Это сообщение появляется тогда,  когда один из аргументов  ди-
         рективы SEGMENT неправильный. Например:

              DATA SEGMENT PAFA PUBLIC ; должно быть PARA

                                                                               
         Can't add relative quantities
         (нельзя складывать относительные величины)

              Это сообщение  появляется тогда,  когда в выражении делается
         попытка сложить две адресные переменные.  Такая операция запреще-
         на. Например:

              ABC DB ?
              DEF = ABC + ABC ; ошибка, это нельзя делать

              Вы можете вычитать два адреса один из другого или прибавлять
         к адресу константу. Например:

              XYZ DB 5 DUP (0)
              XYZEND EQU 5
              XYZLEN = SYZEND - XYZ
              XYZ2 = XYZ + 2

                                                                               
         Can't address with currently ASSUMEd registers
         (нельзя адресоваться к регистрам, которые в данный момент исполь-
         зуются в ASSUME)

              Это сообщение появляется тогда, когда выражение содержит пе-
         ременную, для достижения которой не определен сегментный регистр.
         Например:

              DSEG SEGMENT
                ASSUME DS:DSEG
                 mov SI,MPTR
              DSEG ENDS
              XSEG SEGMENT
                   MPTR  DW  ?
              XSEG ENDS


         TASM2 #5-5/Док              = 157 =

                                                                               
         Can't convert to pointer
         (невозможно преобразовать к указателю)

            Это сообщение появляется тогда, когда часть выражения не может
         быть преобразована в указатель на память (memory pointer) при по-
         мощи операции PTR:

              mov  cl,[BYTE PTR al]

                                                                               
         Can't emulate 8087 instruction
         (невозможно эмулировать инструкцию процессора 8087)

              Это сообщение  появляется тогда,  когда TASM должен эмулиро-
         вать инструкции для работы с данными с  плавающей  точкой  (опция
         командной строки /E или директива EMUL),  но эмуляция данной инс-
         трукции невозможна. Например:

              EMUL
              FNSAVE [WPTR]

              Следующие команды не поддерживаются эмулятором: FNSAVE, FNSTCW
         FNSTENV и FNSTSW.

                                                                               
         Can't make variable PUBLIC
         (переменную невозможно сделать общедоступной)

              Это сообщение появляется тогда,  когда переменная уже объяв-
         лена иначе и не может быть сделана общедоступное (PUBLIC). Напри-
         мер:

              EXTRN ABC:NEAR
              PUBLIC ABC    ; ошибка, уже EXTRN

                                                                               
         Can't override ES segment
         (нельзя переопределить сегмент ES)

              Это сообщение  появляется  тогда,  когда текущий операнд ис-
         пользует вместо сегментного регистра ES другой регистр. Например:

              STOS DS:BYTE PTR [DI]

              В этой инструкции можно использовать только регистр ES.

         TASM2 #5-5/Док              = 158 =


                                                                               
         Can't subtract dissimillar relative quantities
         (нельзя вычитать разные относительные величины)

              Это сообщение появляется тогда, когда в выражении вычитаются
         друг из друга два адреса,  находящиеся в разных сегментах. Напри-
         мер:

              SEG1 SEGMENT
              A:
              SEG1 ENDS
              SEG2 SEGMENT
              B:
                mov ax,B-A      ; ошибка
              SEG2 ENDS

                                                                               
         Can't use macro name in expression
         (в выражении нельзя использовать имя макрокоманды)

              Это сообщение появляется тогда,  когда имя макрокоманды  ис-
         пользуется вами в выражении. Например:

              Mymac  MACRO
                     ENDM
                     mov ax,MYMAC

                                                                               
         Can't use outside macro
         (нельзя использовать внешнюю макрокоманду)

              Это сообщение появляется тогда,  когда вы используете дирек-
         тивы, имеющие смысл лишь внутри макроопределений. Например:

              DATA SEGMENT
                ENDM

                                                                               
         Code or data emission to undeclared segment
         (код или данные в неописанном сегменте)

              Это сообщение появляется тогда, когда первая инструкция фай-
         ла встречена до объявления сегмента. Например:

              ; Первая строка файла

         TASM2 #5-5/Док              = 159 =

                  INC bx           ; ошибка
                  END

                                                                               
         Constant assumed to mean immediate constant
         (подразумевается использование непосредственной константы)

              Данное предупреждение  появляется, если вы используете такое
         выражение, как  [0],  что в MASM интерпретируется,  как просто 0.
         Например:

              mov ax[0]    ; означает mov ax,0 а не mov ax,DS:[0]

                                                                               
         Constant too large
         (константа слишком велика)

              Это сообщение появляется тогда,  когда вы использовали слиш-
         ком большое значение константы.  Напомним, что константы, большие
         чем 0FFFFh могут быть использованы только после применения дирек-
         тив .386 или 386P.

                                                                               
         CS not correctly assumed
         (некорректно подразумевается CS)

              Данное сообщение  появляется  тогда,  когда  инструкции CALL
         (near) или JMP ближнего типа (near) не могут  передать управление
         по адресу, так как он находится в другом сегменте. Например:

              SEG1 SEGMENT
              LAB1 LABEL NEAR
              SEG1 ENDS
              SEG2 SEGMENT
                   JMP LAB1
              SEG2 ENDS

              Такая ошибка может появиться только в режиме MASM,  в режиме
         Ideal она исправляется транслятором.

                                                                               
         CS override in protected mode
         (переопределение регистра CS в защищенном режиме)

              Это сообщение  появляется  тогда,  когда  текущая инструкция
         требует изменения содержимого регистра  CS  для  микропроцессоров

         TASM2 #5-5/Док              = 160 =

         80286  или в защищенном режиме (директивы P286 или P386).  Напри-
         мер:

              P286
               .CODE
              CVAL DW  ?
                mov CVAL,1

              Параметр командной строки /P подавляет это предупреждение.

                                                                               
         CS unreachable from current segment
         (регистр CS недостижим из текущего сегмента)

              Это сообщение появляется тогда,  когда при определении метки
         директивами LABEL,  PROC, (:) регистр CS не указывает ни на теку-
         щий сегмент кода,  ни на группу,  содержащую этот сегмент. Напри-
         мер:

              PROG1 SEGMENT
               ASSUME CS: PROG2
                START :

                                                                               
         Declaration needs name
         (в описаниях требуется имя)

            Это сообщение  появляется тогда,  когда в директиве не указано
         имя идентификатора. Например:

              PROC
                 RET
              ENDP

              Имя используется в директивах SEGMENT, PROC и STRUC. В режи-
         ме MASM оно располагается до директивы,  а в режиме  Ideal  -  до
         нее.

                                                                               
         Directive ignored in Turbo Pascal model
         (в модели Турбо Паскаля директива игнорируется)

              Это сообщение появляется тогда, когда вы пытаетесь использо-
         вать директивы которые не могут находиться в модуле,  взаимодейс-
         твующим с программой на Турбо Паскале. (См. Главу 3 данного руко-
         водства и Главу 7 "Руководства пользователя").

         TASM2 #5-5/Док              = 161 =


                   Directive not allowed inside structure definition           
         (внутри определения структуры данная директива не разрешена)

              Это сообщение  появляется  тогда,  когда  внутри   определения
         структуры вы использовали директиву, которая там появляться не
         может. Например:

              X STRUC
              MEM1 DB ?
                ORG $+4   ; ошибка, этого делать нельзя
              MEM2 DW  ?
              ENDS

              При объявлении вложенной структуры вы не  можете присваивать
         ей значение. Например:

              FOO STRUC
                 FOO2 STRUC     ; ошибка
                 ENDS
              ENDS

              Если вы хотите использовать поименованную  структуру  внутри
         другой структуры, то сначала нужно определить ее, а затем исполь-
         зовать ее имя в другой структуре.

                                                                               
         Duplicate dummy argument:_
         (дублируется подставляемый аргумент)

            Данное сообщение появляется тогда,  когда вы определили макро-
         команду при помощи директивы MACRO, у которой фиктивные аргументы
         имеют одно и то же имя. Например:

              XYZ  MACRO A,A
                   DB A
              XYZ  ENDM

                                                                               
         ELSE or ENDIF without IF
         (директива ELSE или ENDIF без IF)

              Данное сообщение появляется тогда,  когда TASM встречает не-
         парные директивы ELSE или EDIF и IF. Например:


         TASM2 #5-5/Док              = 162 =

              BUF DB 10 DUP ?
                ENDIF

                                                                               
         Expecting offset quantity
         (ожидается смещение)

              Данное сообщение появляется тогда,  когда в выражении встре-
         чается операнд,  ссылающийся на смещение внутри сегмента, но пра-
         вая часть операнда не найдена в тексте. Например:

              CODE SEGMENT
                mov ax,LOW CODE
              CODE ENDS

                                                                               
         Expecting offset or pointer quantity
         (ожидается смещение или указатель)

              Данное сообщение появляется тогда,  когда в выражении встре-
         чается операнд, ссылающийся на смещение внутри определенного сег-
         мента, но правая часть операнда не найдена в тексте. Например:

              CODE SEGMENT
                mov ax,SEG CODE

              CODE ENDS

                                                                               
         Expecting pointer type
         (ожидается ссылочный тип)

              Данное сообщение появляется тогда, когда в инструкции ожида-
         ется операнд, ссылающийся на область памяти. Например:

              LES di,4 ; Ошибка, 4 - константа

                                                                               
         Expecting scalar type
         (нужен скалярный тип)

              Данное сообщение появляется тогда, когда в инструкции ожида-
         ется операнд-константа. Например:

              BB DB 4
                 ROL ax,BB  ; для ROL требуется константа

         TASM2 #5-5/Док              = 163 =


                                                                               
         Expecting segment or group quantity
         (требуется сегмент или группа)

              Данное сообщение появляется тогда, когда операнду необходимо
         имя сегмента или имя группы, но оно указано неверно. Например:

              DATA SEGMENT
                 ASSUME DS:FOO
                   FOO DW 0
              DATA ENDS

                                                                               
         Extra characters on line
         (лишние символы в строке)

              Данное сообщение появляется тогда, когда TASM встречает пра-
         вильное выражение, но в нем присутствуют "лишние" символы. Напри-
         мер:

              ABC = 4 SHL 3 3 ; пропущен оператор между 3 и 3

                                                                               
         Forward reference needs override
         (опережающие ссылки требуют переопределения)

              Данное сообщение появляется либо  тогда,  когда  переменная,
         неопределенная  к данному моменту трансляции,  либо для доступа к
         переменной требуется замена префикса сегмента. Например:

              ASSUME CS:DATA
                CALL A
              A PROC FAR
                  mov ax,MEMVAR
              DATA SEGMENT
              MEMVAR DW ?

                                                                               
         Global type doesn't match symbol type
         (глобальный тип не совпадает с типом идентификатора)

              Данное предупреждение выдается, когда идентификатор описыва-
         ется с помощью оператора GLOBAL и описывается также в этом  моду-
         ле, но тип,  указанный в GLOBAL, и действительный тип идентифика-
         тора не согласуются.

         TASM2 #5-5/Док              = 164 =


                                                                               
         ID not member of structure
         (идентификатор не является элементом структуры)

              Данное сообщение появляется тогда, когда в улучшенном режиме
         (Ideal)  вы  использовали  символическое  имя,  не  принадлежащее
         структуре, после оператора (.). Например:

              IDEAL
              STRUC DEMO
                DB ?
              ENDS
              COUNT  DW 0
               mov ax,[DEMO bx].COUNT] ; COUNT - не входит в структуру

                                                                               
         Illegal forward reference
         (недопустимая опережающая ссылка)

              Данное сообщение появляется тогда,  когда в директиве указан
         идентификатор, значение  которого  в данный момент не определено.
         Например:

              IF MYSYM   ; Ошибка, символ не определен
                ...
                ...
              ENDIF
              MYSYM EQU 1

                                                                               
         Illegal immediate
         (недопустимый непосредственный операнд)

            Данное сообщение появляется тогда,  когда в инструкции исполь-
         зуется константа там, где она не разрешена. Например:

              mov 4,al

                                                                               
         Illegal indexing mode
         (недопустимый режим индексирования)

              Данное сообщение появляется тогда, когда инструкция содержит
         операнд,  являющийся неразрешенной комбинацией регистров.  Напри-
         мер:

         TASM2 #5-5/Док              = 165 =


              mov al,[si+ax]

              Для всех процессоров,  кроме 80386, допустимыми комбинациями
         регистров являются: BX,BP,SI,DI,BX+SI,BX+DI,BP+SI,BP+DI.

                                                                               
         Illegal instruction
         (недопустимая инструкция)

              Данное сообщение появляется тогда,  когда  строка  исходного
         текста содержит идентификатор, который не является ни директивой,
         ни мнемоникой инструкции. Например:

              move ax,4  ; должно быть "mov"

                                                                               
         Illegal instruction for currently selected processor(s)
         (недопустимая инструкция для выбранного в данный момент процессо-
         ра)

              Данное сообщение  появляется  тогда,  когда строка исходного
         текста содержит такую инструкцию, которая не может быть ассембли-
         рована для текущего процессора. Например:

              .8086
              PUSH 1234H ; нет непосредственной команды PUSH для 8086

              В начале ассемблирования TASM генерирует  инструкции  только
         для микропроцессора 8086. Для того, чтобы ассемблировать инструк-
         ции для микропроцессоров 80186/80286/80386,  вы должны  использо-
         вать одну из директив (P186,P286,P386).

                                                                               
         Illegal local argument
         (недопустимый локальный аргумент)

               Данное сообщение появляется тогда, когда в директиве LOCAL,
         которая находится внутри макроопределения, находится некорректное
         имя идентификатора. Например:

              X   MACRO
                LOCAL 123  ; Ошибка, это не идентификатор
                  ENDM



         TASM2 #5-5/Док              = 166 =

                                                                               
         Illegal local symbol prefix

         (недопустимый префикс локального идентификатора)

              Данное сообщение  появляется  тогда,  когда директива LOCALS
         содержит некорректный новый префикс,  с которого будут начинаться
         локальные идентификаторы. Например:

              LOCALS XYZ  ; Ошибка, не 2 идентификатора.

              Префикс локальных  идентификаторов  должен быть не более 2-х
         идентификаторов, которые должны удовлетворять  соглашениям  языка
         Ассемблера.

                                                                               
         Illegal macro argument
         (недопустимый аргумент макрокоманды)

              Данное сообщение появляется тогда, когда макрокоманда, опре-
         деленная директивой MACRO,  содержит в качестве фиктивного  аргу-
         мента некорректное имя идентификатора. Например:

              X MACRO  123   ; Неправильное имя
                ENDM

                                                                               
         Illegal memory reference
         (недопустимая ссылка на память)

              Данное сообщение появляется тогда,  когда в  инструкции  ис-
         пользуется операнд, ссылающийся на область памяти, в то время как
         это не разрешено. Например:

              mov [bx],BYTE PTR A ; Ошибка, нельзя пересылать из памяти в
                                    память

                                                                               
         Illegal number
         (недопустимое число)

              Данное сообщение появляется тогда, когда число содержит один
         или несколько недопустимых символов. Например:

              Z = 0ABCGH

              В этом примере G - недопустимый символ.

         TASM2 #5-5/Док              = 167 =


                                                                               
         Illegal origin address
         (недопустимый начальный адрес)

              Данное сообщение появляется тогда,  когда вы установили неп-
         равильное значение счетчика адреса ($).

                                                                               
         Illegal override in structure
         (недопустимое переопределение в структуре)

              Данное сообщение появляется тогда, когда вы пытаетесь иници-
         ализировать элемент структуры,  который был определен при  помощи
         операции DUP.  Вы можете инициализировать лишь те элементы струк-
         туры, которые были объявлены без использования DUP.

                                                                               
         Illegal override register
         (недопустимое переопределение регистра)

              Данное сообщение появляется тогда, когда для замены сегмента
         в  инструкции используется регистр,  отличный от сегментного (ES,
         DS, SS, CS). Например:

              mov dx:XYZ,1

                                                                               
         Illegal radix
         (недопустимое основание)

              Данное сообщение появляется тогда,  когда в директиве .RADIX
         вы указали некорректное число. Например:

              .RADIX  7  ; Ошибка

              Число в  директиве .RADIX может принимать следующие значения
         :2, 8, 16.

                                                                               
         Illegal register multiplier
         (недопустимый коэффициент регистра)

              Данное сообщение появляется тогда,  когда вы пытались  умно-
         жить регистр на константу,  что является неразрешенной операцией.
         Например:

         TASM2 #5-5/Док              = 168 =


              mov ax*3,1

                                                                               
         Illegal segnemt address
         (недопустимый адрес сегмента)

              Данная ошибка возникает,  если в качестве постоянного адреса
         сегмента задан адрес, больший 65535, например:

                 FOO SEGMENT AT 12345h

                                                                               
         Illegal use of constant
         (недопустимое использование константы)

              Данное сообщение появляется тогда, когда константа появляет-
         ся в таком выражении, где константы не используются. Например:

              mov bx+4,5

                                                                               
         Illegal use of register
         (недопустимое использование регистра)

              Данное сообщение  появляется  тогда,  когда вы используете в
         выражении имя регистра. Например:

              X = 4 SHL ax ; здесь ax нельзя использовать

                                                                               
         Illegal use of segment register
         (недопустимое использование сегментного регистра)

              Данное сообщение появляется тогда, когда имя сегментного ре-
         гистра  используется в тех выражениях или инструкциях,  в которых
         оно использоваться не может. Например:

              ADD  SS,4

                                                                               
         Illegal USES register
         (недопустимый регистр в USES)

              Данное сообщение появляется тогда, когда вы использовали не-
         допустимые имена регистров,  сохраняемых при входе и восстанавли-

         TASM2 #5-5/Док              = 169 =

         ваемых при выходе из процедуры. Допустимые имена регистров следу-
         ющие:

                AX    CX    DS    ES
                BX    DI    DX    SI

              Если вы разрешили использование  инструкций  микропроцессора
         80386 при помощи директив (.386 или .386P),  то вы можете исполь-
         зовать 32-разрядные эквиваленты этих регистров.

                                                                               
         Illegal warning ID
         (недопустимый идентификатор предупреждений)

              Данное сообщение появляется  тогда,  когда  вы  использовали
         неправильный трехбуквенный идентификатор предупреждающего сообще-
         ния. Для ознакомления с полным списком идентификаторов предупреж-
         дающих сообщений см. Главу 3 "Руководства пользователя".

                                                                               
         Instruction can be compacted with override
         (инструкция может быть уменьшена при переопределении)

              Данное сообщение появляется тогда,  когда TASM сообщает, что
         возможно уменьшение размера инструкции. Например:

                JMP   ABC
                  ...
                ABC :     ; возможно уменьшить размер инструкции, применив
                          ; префикс SHORT  (JMP SHORT ABC)
                  ...

                                                                               
         Invalid mode type
         (недопустимый тип режима)

              Данное сообщение появляется тогда, когда вы неправильно указали в
         директиве .MODEL ключевое слово, определяющее  модель  памяти.

              Например:

                 .MODEL GIGANTIC

              Допустимые значения  этого  ключевого  слова:  tiny,  small,
         medium, large, huge.


         TASM2 #5-5/Док              = 170 =

                                                                               
         Invalid operand(s) to instruction
         (недопустимые операнды в инструкции)

              Данное сообщение появляется тогда, когда инструкция содержит
         недопустимую комбинацию операндов. Например:

              FADD ST(2),ST(3)

              Здесь инструкция  FADD может ссылаться только на один стеко-
         вый регистр по имени, другой должен быть вершиной стека.

                                                                               
         Labels can't start with numeric character
         (метка не может начинаться с числового символа)

              Данное сообщение появляется тогда,  когда вы  ввели  символ,
         который не является ни числом, ни именем, например 123XYZ.

                                                                               
         Line is too long - truncating
         (строка слишком длинная - усекается)

              Длина текущей строки исходного файла превышает 255 символов.
         Символы, выходящие за пределы 255 символов, игнорируются.

                                                                               
         Location counter overflow
         (переполнение счетчика адреса)

              Данное сообщение появляется тогда, когда текущий сегмент ко-
         да  исчерпан,  а  последующий код генерируется с начала сегмента.
         Например:

              ORG 0FFF0H
              ARRAY DW 20 DUP (0) ; переполнение.

                                                                               
         Missing argument list
         (пропущен список аргументов)

              Данное сообщение  появляется  тогда,  когда  директивы IRP и
         IRPC не содержат аргумента для замены на фиктивный параметр. Нап-
         ример:

              IRP X

         TASM2 #5-5/Док              = 171 =

                 DB X
              ENDM

              Директивы IRP  и  IRPC  должны содержать как фиктивный пара-
         метр, так и список аргументов.

                                                                               
         Missing argument of <
         (пропущен аргумент <)

              Вы забыли там, где это требуется, указать угловые скобки или
         целое выражение. Например:

              ifb    ; нужен аргумент в угловых скобках

                                                                               
         Missing argument size variable
         (пропущен аргумент размера переменной)

              Данное сообщение появляется тогда,  когда в директивах ARG и
         LOCAL не указано имя после символа (=). Например:

              ARG A:WORD,B:DWORD= ; Ошибка, нет имени после =
              LOCAL X:TBYTE =     ; такая же ошибка

              В директивах ARG и LOCALS имя должно всегда  следовать после
         символа (=) для того,  чтобы определить размер памяти,  отводимой
         под переменную.

                                                                               
         Missing COMM ID
         (пропущен идентификатор в COMM)

              Данное сообщение появляется тогда,  когда в  директиве  COMM
         указан тип, но не указано имя общей переменной. Например:

              COMM NEAR

              Директива COMM всегда должна содержать имя и тип переменной,
         разделенные знаком (:).

                                                                               
         Missing dummy argument
         (пропущен фиктивный аргумент)

              Данное сообщение появляется тогда,  когда в  директивах  IRP

         TASM2 #5-5/Док              = 172 =

         или IRPC отсутствует фиктивный параметр. Например:

              IRP
                 DB X
              ENDM

              Директивы IRP  и  IRPC  должны содержать как фиктивный пара-
         метр, так и список аргументов.

                                                                               
         Missing end quote
         (пропущена закрывающая кавычка)

              Данное сообщение появляется тогда,  когда строка символов не
         заканчивается знаком " или '. Например:

              DB "abc     ;
              mov  al,'X  ;

              Строки символов должны заканчиваться символом " или ', в за-
         висимости от того, с какого знака строка начиналась.

                                                                               
         Missing macro ID
         (пропущен идентификатор макрокоманды)

              Данное сообщение  появляется тогда,когда макрос определенный
         по директиве MACRO, не имеет имени. Например:

              MACRO       ; Ошибка, нет имени
                  DB A
                   ENDM

            При определении макрокоманды ему всегда должно  быть присвоено
         имя.

                                                                               
         Missing module name
         (пропущено имя модуля)

              Данное сообщение появляется тогда,  когда вы используете ди-
         рективу NAME без указания имени модуля. Запомните, что эту дирек-
         тиву можно использовать только в режиме Ideal.

                                                                               
         Missing or illegal language ID

         TASM2 #5-5/Док              = 173 =

         (пропущенный или недопустимый идентификатор языка)

              Данное сообщение появляется тогда,  когда в директиве .MODEL
         вы указали отличный от разрешенного идентификатор языка. Для пол-
         ного описания директивы .MODEL см. Главу 3 данного руководства.

                                                                               
         Missing or illegal type specifier
         (пропущен или недопустим спецификатор типа)

              Данное сообщение появляется тогда,когда в операторе, требую-
         щем определение типа,  тип не указан,  либо  указан  неправильно.
         Например:

              RED LABEL XXX ; 'XXX' -- не указатель типа.

                                                                               
         Missing term in list
         (пропущен элемент списка)

              В режиме  Ideal директивы могут содержать несколько аргумен-
         тов,  которые разделяются запятыми.  Данное сообщение  появляется
         тогда, когда пропущен один из этих аргументов. Например:

              EXTRN XXX:BYTE,,YYY:WORD

              В режиме  Ideal  все элементы списка должны быть разделены в
         точности одной запятой,  а в конце списка запятой не должно быть.

                                                                               
         Missing text macro
         (пропущена текстовая макрокоманда)

            Данное сообщение появляется тогда, когда пропущен текст макро-
         команды.

                                                                               
         Model must be specified first
         (модель должна задаваться первой)

              Данное сообщение появляется тогда, когда вы использовали од-
         ну из директив управления сегментами раньше,  чем определили  мо-
         дель памяти при помощи директивы .MODEL. Например:

              .CODE  ; Ошибка, первой директивой должна быть .MODEL


         TASM2 #5-5/Док              = 174 =

              Вы всегда  должны  перед  использованием директив управления
         сегментами определить модель памяти.

                                                                               
         Module is pass dependent - compatibility pass was done
         (модуль зависит от нескольких проходов:  выполнен проход для сов-
         местимости)

              Данное предупреждение появляется в случае обнаружения  конс-
         трукции, зависящей от прохода и задании параметра командной стро-
         ки /m. Выполнен проход в целях совместимости с MASM.

                                                                               
         Name must come first
         (имя должно следовать первым)

              Данное сообщение появляется тогда,  когда вы  поместили  имя
         идентификатора  после  директивы,  в то время как оно должно быть
         перед ней. Например:

              STRUC ABC

                                                                               
         Near jump or call to different CS
         (вызов или переход ближнего типа на другой CS)

              Данная ошибка   возникает,   если   пользователь    пытается
         выполнить инструкции NEAR CALL или JMP на идентификатор,  опреде-
         ленный в области,  где регистру CS присваивается значение другого
         сегмента.

                                                                               
         Need address or register
         (нужен адрес или регистр)

              Данное сообщение появляется тогда,  когда инструкция не  со-
         держит второго операнда,  даже если есть запятая между ними. Нап-
         ример:

              mov ax,      ; нет второго операнда

                                                                               
         Need angle brackets for structure fill
         (для заполнения структуры необходимы угловые скобки)

              Данное сообщение появляется тогда,  когда оператор, выделяю-

         TASM2 #5-5/Док              = 175 =

         щий память под структуру не содержит списка инициализации. Напри-
         мер:

              STR1 STRUC
               M1 DW   ?
               M2 DW   ?
                 ENDS
                STR1   ; нет списка инициализации

                                                                               
         Need colon
         (требуется двоеточие)

              Данное сообщение появляется тогда,  когда в операнде(ах) ди-
         ректив EXTRN, LOCAL, GLOBAL, ARG пропущен знак (:). Например:

              EXTRN X BYTE,Y:WORD ;

                                                                               
         Need expression
         (требуется выражение)

              Данное сообщение появляется тогда,  когда выражение содержит
         операцию с пропущенным операндом. Например:

              X= 4 + * 6

                                                                               
         Need file name after INCLUDE
         (после INCLUDE требуется указывать имя файла)

              Данное сообщение появляется  тогда,  когда  после  директивы
         INCLUDE отсутствует имя файла. Например:

              INCLUDE     ; Ошибка, неясно что включать

              В режиме Ideal имя должно быть заключено в кавычки.

                                                                               
         Need left parenthesis
         (требуется левая скобка)

              Данное сообщение появляется тогда,  когда в выражении пропу-
         щена левая скобка. Например:

              DB  4 DUP 7

         TASM2 #5-5/Док              = 176 =


              Выражение, следующее за операцией DUP,  всегда должно быть в
         скобках.

                                                                               
         Need pointer expression
         (требуется ссылочное выражение)

              Эта ошибка встречается только в режиме Ideal. Данное сообще-
         ние означает,  что значением выражения в скобках ([]) является не
         указатель. Например:

              mov ax,[word ptr]

                                                                               
         Need quoted string
         (требуется строка, заключенная в кавычки)

              Данное сообщение появляется тогда, когда вместо строки, зак-
         люченной в кавычки вы указали что-то другое.  В режиме Ideal  для
         некоторых директив необходимо указать в качестве операнда строку,
         заключенную в кавычки. Например:

              IDEAL
              DISPLAY "ALL DONE "

                                                                               
         Need register in expression
         (в выражении требуется регистр)

              Данное сообщение появляется тогда, когда выражение не содер-
         жит требуемого имени регистра.

                                                                               
         Need right angle brackets
         (требуется правая угловая скобка)

              Данное сообщение появляется тогда,  когда список инициализа-
         ции структуры не закрыт угловой скобкой (>). Например:

              MYSTRUC STRUCNAME <1,2,3

                                                                               
         Need right parenthesis
         (требуется правая скобка)


         TASM2 #5-5/Док              = 177 =

              Данное сообщение появляется тогда,  когда в выражении пропу-
         щена правая скобка. Например:

              X = 5 * (4 + 3

                                                                               
         Need right square bracket
         (требуется правая квадратная скобка)

              Данное сообщение появляется тогда, когда в выражении отсутс-
         твует правая скобка (]). Например:

              mov ax,[SI

                                                                               
         Need stack argument
         (требуется аргумент стека)

              Данное сообщение появляется тогда, когда инструкция работы с
         числами с плавающей точкой не содержит второго  операнда.  Напри-
         мер:

              FADD ST,

                                                                               
         Need structure member name
         (необходимо имя элемента структуры)

              Данное сообщение появляется тогда, когда в режиме Ideal опе-
         ратор определения элемента директивы (.) находится рядом  с  име-
         нем, не являющимся именем элемента структуры. Например:

              IDEAL
               STRUC DEMO
                A DB ?
               ENDS
                  mov ax,C.DEMO

                                                                               
         Not expected group or segment quantity
         (нельзя использовать группу или сегмент)

              Вы использовали имя сегмента или группы там,  где этого  де-
         лать нельзя, например:

              CODE SEGMENT

         TASM2 #5-5/Док              = 178 =

                   rol   ax,CODE   ; ошибка, здесь нельзя использовать
                                   ; сегмент

                                                                               
         One non-null field allowed per union expansion
         (в расширении объединения допускается одно ненулевое поле)

              Когда в  директиве  UNION определена инициализация объедине-
         ния,  было задано более одного значения, например:

              U       UNION
                      DW   ?
                      DD   ?
              ENDS
              UINST   U <1,2>   ; ошибка, должно быть <?,> или <1,?>

              Объединение может инициализироваться только одним значением.

                                                                               
         Only one startup sequence allowed
         (допускается только одна последовательность инициализации)

              Эта ошибка возникает,  если у вас в модуле содержится  более
         одного оператора .STARTUP или STTARTUPCODE.

                                                                               
         Open conditional
         (открытое условие)

              Достигнут конец  исходного  файла,  определенный  директивой
         END, но блок  условного  ассемблирования,  начатый  по  директиве
         IFxxx, не закрыт директивой ENDIF. Например:

              IF BIGBUF
              END               ; перед END нет ENDIF

              Обычно это происходит, когда вы для закрытия условного блока
         вместо ENDIF используете END.

                                                                               
         Open procedure
         (открытая процедура)

              Достигнут конец  исходного  файла,  определенный  директивой
         END, но процедурный блок,  начатый по директиве PROC,  не был за-
         вершен директивой ENDP. Например:

         TASM2 #5-5/Док              = 179 =


              MYFUNC PROC
                   END      ; перед ENDIF нет ENDP

              Обычно это происходит,  когда вы для  закрытия  процедурного
         блока вместо ENDP используете END.

                                                                               
         Open segment
         (открытый сегмент)

              Данное сообщение появляется тогда,  когда отсутствует дирек-
         тива ENDS, закрывающая данный сегмент. Например:

              DATA SEGMENT ; Отсутствует директива ENDS
                 END

              Обычно это бывает тогда, когда вы использовали  директиву  END
         раньше директивы ENDS.

                                                                               
         Open structure definition
         (открытое определение структуры)

              Данное сообщение появляется тогда, когда конец файла достиг-
         нут,  а структура, открытая при помощи директивы STRUC не закрыта
         директивой ENDS. Например:

              X STRUC
              VAL1 DW  ?
                END

              Обычно это  бывает  тогда, когда вы использовали директиву END
         раньше директивы ENDS.

                                                                               
         Operand types do not match
         (не совпадают типы операндов)

              Данное сообщение появляется тогда, когда размер операнда инструк-
         ции определен вами неправильно. Например:

              ABC   DB  5
                 ...
                 ...
                 mov  ax,ABC

         TASM2 #5-5/Док              = 180 =


                                                                               
         Pass-dependent construction encountered
         (обнаружена конструкция, зависимая от прохода)

              Данное сообщение появляется тогда, когда операция ведет себя
         не так,  как вы ожидаете.  Данное происходит потому, что в TASM -
         используется однопроходной режим. Например:

              IF1
                          ; Используется при ассемблировании

              ENDIF
              IF2
                          ; Используется при формировании листинга

              ENDIF

              Большинство конструкций,  генерирующих данную ошибку,  можно
         переписать таким  образом,  чтобы избежать ее (удалив опережающие
         ссылки).

                                                                               
         Pointer expression need brackets
         (в ссылочном выражении требуются угловые скобки)

              В режиме Ideal операнды,  содержащие идентификаторы, ссылаю-
         щиеся на память,  не заключаются в квадратные скобки, чтобы пока-
         зать, что это ссылка на память. Например:

              B   DB  0
                  mov  al,B     ; предупреждение: в режиме Ideal нужно [B]

              Так как режим MASM не требует использования  квадратных ско-
         бок, это только предупреждение.

                                                                               
         Positive count expected
         (нужно положительное значение счетчика)

              В операции DUP содержится счетчик повторения < 0. Например:

                BUF   -1  DUP (?)   ;  ошибка, счетчик < 0

              Значение счетчика в этом случае должно быть не меньшим 1.


         TASM2 #5-5/Док              = 181 =

                                                                               
         Quantity illegal
         (недопустимая величина)

              Данное сообщение появляется тогда,  когда инструкция или ди-
         ректива  содержат операнд,  ссылающийся на участок памяти,  неиз-
         вестный во время ассемблирования. Например:

              SEGMENT PUBLIC
              X  DB 0
              Y  = OFFSET X GT 127

                                                                               
         Record field too large
         (поле записи слишком велико)

              Когда вы  определили  запись,  общий   размер   всех   полей
         превышает 32 бита. Например:

                 AREC RECORD   RANGE:12,TOP:12,BOTTOM:12

                                                                               
         Recursive definition not allowed for EQU
         (для EQU не допускается рекурсивное определение)

              Определение EQU содержит то же имя,  которое вы определили в
         самом определении. Например:

                  ABC  EQU  TWOTIMES ABC

                                                                               
         Register must be AL or AX
         (должен использоваться регистр AL или AX)

                                                                               
         Register must be DX
         (должен использоваться регистр DX)

              В инструкции, в которой в качестве одного операнда требуется
         указывать регистр DX, указан недопустимый операнд. Например:

              IN   AL,cx  ; ошибка, вместо CX нужно использовать DX

                                                                               
         Relative jump out of range by ___ bytes
         (относительный переход выходит за допустимую границу на указанное

         TASM2 #5-5/Док              = 182 =

         число байт)

              Делается попытка условного перехода по адресу,  который отс-
         тоит более,  чем на 128 байт от текущего. Если это сегмент USE32,
         то в условных переходах можно ссылаться на 32768 байта до текуще-
         го адреса и на 32767 после него.

                                                                               
         Relative quantity illegal
         (недопустимая относительная величина)

              Инструкция или директива содержит операнд, который ссылается
         на адрес памяти таким образом, что он неизвестен во время ассемб-
         лирования, а это не допускается. Например:

              DATA SEGMENT PUBLIC
              X    DB    0
                   IF    OFFSET X GT 127   ; неизвестно во время ассембли-
                                           ; рования

                                                                               
         Reserved word used as symbol
         (в качестве идентификатора использовано зарезервированное слово)

              В вашей программе идентификатор имеет имя, которое использу-
         ется в самом Турбо Ассемблере.  Программа будет  ассемблироваться
         правильно, но лучше не использовать зарезервированные слова.

                                                                               
         Rotate count must be constant or CL
         (счетчик циклического сдвига должен задаваться константой или ре-
         гистром CL)

              Инструкция сдвига или циклического сдвига записана с операн-
         дом, который не является ни константой, ни регистром CL. Например:

              rol   ax,DL  ; ошибка, DL нельзя использовать в качестве
                           ; счетчика

              В качестве второго операнда в таких  инструкциях допускается
         использовать только константу или регистр CL.

                                                                               
         Rotate couunt out of range
         (значение счетчика сдвига превышает допустимый диапазон)


         TASM2 #5-5/Док              = 183 =

              В инструкции  сдвига  или  циклического  сдвига задан второй
         операнд со слишком большим значением. Например:

              .8086
              shl   DL,3  ; ошибка, при использовании 8086 можно сдвигать
                          ; только на 1
              .286
              ror   ax,40 ; ошибка, максимальный сдвиг - 31

              Процессор 8086 позволяет использовать  в  качестве  счетчика
         сдвига  только  значение  1,  а другие процессоры - значения,  не
         превышающие 31.

                                                                               
         Segment aligment not strict enough
         (недостаточно строгое выравнивание сегмента)

              Указанное значение границы выравнивания недопустимо. Оно ли-
         бо не является степенью числа 2, либо задает более строгое вырав-
         нивание, чем тем выравнивания в директиве SEGMENT. Например:

              DATA SEGMENT PARA
                   ALIGN   32 ; ошибка, PARA допускает только 16
                   ALIGN   3  ; ошибка, это не степень 2

                                                                               
         Segment attributes illegally redefined
         (недопустимое переопределение атрибутов сегмента)

              Директива SEGMENT вновь открывает сегмент, который был ранее
         определен, и пытается задать для него другие атрибуты. Например:

              DATA SEGMENT BYTE PUBLIC
              DATA ENDS
              DATA SEGMENT PARA ; ошибка, ранее было выравнивание на байт
              DATA ENDS

              Если вы повторно открываете сегмент, то указываемые атрибуты
         должны быть  точно  такими же,  как и ранее,  либо их надо совсем
         опустить (в этом случае автоматически используются старые атрибу-
         ты).

                                                                               
         Segment name is superfluous
         (лишнее имя сегмента)


         TASM2 #5-5/Док              = 184 =

              Данное предупреждение выводится в операторе .CODE xxx, когда
         указанная модель не позволяет использовать более  одного сегмента
         кода.

                                                                               
         Smart code generation must be enabled
         (должен быть разрешена эффективная генерация кода)

              Для отдельных  средств  генерации  кода требуется разрешение
         эффективной генерации кода (SMART). Это включает в себя занесение
         в стек указателя,  извлечение его из стека,  или занесение в стек
         константы (только для процессора 8086).

                                                                               
         String too long
         (слишком длинная строка)

              Данное сообщение появляется тогда, когда длина строки симво-
         лов превышает 255 байт.

                                                                               
         Symbol already defined:_
         (идентификатор уже определен)

              Данное сообщение появляется тогда, когда идентификатор, ука-
         занный в этом сообщении (аналогичного типа),  уже  был  объявлен.

              Например:

                 BB DB 1,2,3
                 BB DB ?       ; Ошибка, уже определен

                                                                               
         Symbol already different kind
         (идентификатор уже имеет другой тип)

              Данное сообщение появляется тогда, когда идентификатор, ука-
         занный в этом сообщении (другого типа),  уже был объявлен. Напри-
         мер:

              BB DB 1,2,3
              BB DW ?       ; Ошибка, уже определен как байт

                                                                               
         Symbol has no width or mask
         (идентификатор не имеет длины или маски)

         TASM2 #5-5/Док              = 185 =


              Данное сообщение появляется тогда,  когда операнд в операто-
         рах  WIDTH или MASK не является именем записи или именем поля за-
         писи. Например:

              B  DB 0
                mov ax,MASK B

                                                                               
         Symbol is not a segment or already part of group
         (идентификатор не  является  сегментом или уже представляет собой
         часть группы)

              Данное сообщение появляется тогда,  когда идентификатор либо
         уже принадлежит группе,  либо не является именем сегмента. Напри-
         мер:

              DATA SEGMENT
              DATA ENDS
              DGROUP   GROUP DATA
              DGROUP2  GROUP DATA ; Ошибка, DATA уже принадлежит группе
                                  ; DGROUP

                                                                               
         Text macro expansion exceeds maximum line length
         (текст макрорасширения  превышает  максимально  допустимую  длину
         строки)

              Данная ошибка возникает, когда расширение текста макрокоман-
         ды приводит к превышению максимально допустимой длины.

                                                                               
         Too few operands to instruction
         (в инструкции слишком мало операндов)

              Данное сообщение появляется тогда, когда инструкция содержит
         меньше операндов, чем требуется. Например:

              ADD ax    ; пропущен аргумент

                                                                               
         Too many errors or warnings
         (слишком много ошибок или предупреждений)

              Данное сообщение появляется тогда,  когда количество предуп-
         реждающих сообщений или сообщений об ошибках превысило их  макси-

         TASM2 #5-5/Док              = 186 =

         мальное число. Максимальное количество выводимых на экран сообще-
         ний об ошибках равно 100 (оно может быть увеличено).

                                                                               
         Too many initials values
         (слишком много начальных значений)

               Данное сообщение появляется тогда,когда в списке  инициали-
         зации  структуры  или  объединения вы указали значений больше чем
         необходимо. Например:

              XYZ STRUC
              A1  DB   ?
              A2  DB   ?
              XYZ ENDS
              ANXYZ XYZ <1,2,3> ; Ошибка в структуре только 2 элемента

                                                                               
         Too many registers in expression
         (в выражении слишком много регистров)

              Данное сообщение появляется тогда,  когда выражение содержит
         более одного индексного и одного базового регистров. Например:

             mov ax,[BP+SI+DI]

                                                                               
         Too many USES registers
         (слишком много регистров USES)

              В текущей процедуре вы задали более 8 регистров USES.

                                                                               
         Trailing null value assumed
         (подразумевается завершающее нулевое значение)

             Оператор данных типа DB,  DW и т.д. завершается запятой. TASM
         интерпретирует это, как нулевое значение. Например:

              db 'hello',13,10  ; то же, что и ...,13,10?

                                                                               
         Undefined symbol
         (неопределенный идентификатор)

              Данное сообщение  появляется тогда,  когда оператор содержит

         TASM2 #5-5/Док              = 187 =

         идентификатор, который не объявлен.

                                                                               
         Unexpected end of file (no END directive)
         (непредвиденный конец файла; нет директивы END)

              Данное сообщение появляется тогда, когда последняя директива
         исходного файла отлична от директивы END.

                                                                               
         Unknown character
         (неизвестный символ)

              Данное сообщение  появляется  тогда,  когда строка исходного
         файла содержит символ,  не входящий в состав набора символов TASM
         для образования имен и для использования в выражениях. Например:

              ADD ax,!!

                                                                               
         Unmatched ENDP:_
         (нет соответствия ENDP)

              Данное сообщение появляется тогда,  когда для директивы ENDP
         с указанным именем отсутствует директива PROC, открывающая проце-
         дуру. Например:

              ABC PROC
              XYZ ENDP

                                                                               
         Unmatched ENDS:_
         (нет соответствия ENDS)

              Данное сообщение появляется тогда,  когда для директивы ENDS
         с  указанным  именем  отсутствует  директива  SEGMENT,  STRUC или
         UNION,  открывающая соответственно сегмент, структуру или объеди-
         нение. Например:

               ABC STRUC
               XYZ ENDS
               DATA SEGMENT
               CODE ENDS



         TASM2 #5-5/Док              = 188 =

                                                                               
         USE32 not allowed without .386
         (без директивы .386 директива USE32 не разрешается)

              Данное сообщение появляется тогда, когда вы пытались устано-
         вить 32-разрядный адрес сегмента,  не разрешив предварительно ис-
         пользование микропроцессора 80386.
                                                                               
         User generated error
         (ошибка, сгенерированная пользователем)

              Данное сообщение появляется тогда,  когда ошибка  обнаружена
         директивами,  которые затем формируют сообщение об ошибке. Напри-
         мер:

              .ERR

                                                                               
         USES has no effect without язык
         (USES не действует без определения языка)

              Данное предупреждение  выводится,  когда  вы задали оператор
         USES, но не определили язык.

                                                                               
         Value out of range
         (значение вне диапазона)

              Данное сообщение появляется тогда,  когда константа занимает
         больше памяти, чем ей отводится. Например:

              DB 400


         TASM2 #5-5/Док              = 189 =

                                                                               
         Сообщения о фатальных ошибках
         -----------------------------------------------------------------

              При возникновении фатальных (критических) ошибок TASM  прек-
         ращает ассемблирование исходного модуля. Ниже приведен список со-
         общений о фатальных ошибках:
                                                                               
         Bad switch :_
         (неверный параметр)

            Данное сообщение появляется тогда, когда вы указали неправиль-
         ный параметр командной строки.
                                                                               
         Can't find @file :_
         (невозможно найти командный файл)

              Данное сообщение появляется тогда,  когда вы указали имя не-
         существующего командного файла.

                                                                               
         Can't locate file
         (невозможно найти файл)

              Данное сообщение появляется тогда, когда в директиве INCLUDE
         указан несуществующий файл.

                                                                               
         Error writing to listing file
         (ошибка записи в файл листинга)

              Данное сообщение появляется тогда, когда на диске не хватает
         места для файла листинга.

                                                                               
         Error writing to object file
         (ошибка записи в объектный файл)

              Данное сообщение появляется тогда, когда на диске не хватает
         места для записи объектного файла.

                                                                               
         File not found
         (файл не найден)

              Данное сообщение появляется тогда, когда вы определили в ко-
         мандной строке имя не существующего файла.

         TASM2 #5-5/Док              = 190 =


                                                                               
         File was changed or deleted while assembly in progress
         (при выполнении ассемблирования файл был изменен или удален)

              Данное сообщение появляется тогда, когда во время трансляции
         какая-то  программа  (чаще  всего резидентная) изменила (удалила)
         файл исходного текста.

                                                                               
         Insufficient memory to process command line
         (на хватает памяти для обработки командной строки)

              Данное сообщение появляется либо тогда,  когда длина команд-
         ной  строки  превышает 64 Кбайт,  либо тогда,  когда она не может
         быть размещена в доступной памяти.

                                                                               
         Internal error
         (внутренняя ошибка)

              Данное сообщение  не должно появляться во время нормальной работы
         TASM. При появлении этого сообщения сохраните файл, вызывающий
         его,  и  сообщите  об  этом  в  фирму   Borland.

                                                                               
         Invalid command line
         (недопустимая командная строка)

              Данное сообщение  появляется  тогда,  когда  вы  неправильно
         сформировали командную строку. Например:

                 TASM ,MYFILE

                                                                               
         Invalid number after_
         (недопустимое число после _)

              Данное сообщение появляется тогда,  когда вы правильно опре-
         делили параметры командной строки, но за этими параметрами следу-
         ет неправильный числовой аргумент.

                                                                               
         Maximum macro expansion exceeded
         (превышена память при макрорасширении)


         TASM2 #5-5/Док              = 191 =

              Данное сообщение появляется тогда, когда макрорасширение за-
         нимает большую область памяти,  чем выделено под него TASM (64К).

                                                                               
         Out of hash space
         (превышен размер буферной области)

              Данное сообщение появляется тогда, когда происходит перепол-
         нение  таблицы,  содержащей имена,  определенные в программе.  Ее
         "емкость" - 16.384 идентификатора (по умолчанию). Для того, чтобы
         увеличить  емкость  этой  таблицы  используйте параметр командной
         строки /KH.
                                                                               
         Out of memory
         (не хватает памяти)

              Данное сообщение появляется тогда,  когда программе TASM  не
         хватает места в памяти для трансляции исходного модуля.  Если па-
         мять занята резидентными программами, то сначала попытайтесь уда-
         лить  их  из памяти,  а если это не получается,  то перезагрузите
         систему.  Также можно разбить файл на несколько  файлов  меньшего
         размера, уменьшить  длину  имен идентификаторов,  сократить число
         комментариев в макрокомандах.
                                                                               
         Out of string space
         (превышен объем строкового пространства)

              Данное сообщение появляется тогда,  когда не хватает  памяти
         для размещения имен идентификаторов,  текста макрокоманд. Для то-
         го,  что бы увеличить размер памяти,  отводимой под строки,  вос-
         пользуйтесь параметром командной строки /KS.
                                                                               
         Too many errors found
         (обнаружено слишком много ошибок)

              Данное сообщение  появляется  тогда,  когда  TASM  обнаружил
         слишком много ошибок в вашей программе (100 ошибок).

                                                                               
         Unexpected end of file (no END directive)
         (непредвиденный конец файла, нет директивы END)

              Данное сообщение появляется тогда, когда последняя директива
         исходного файла отлична от END.
 
